<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2023/11/23/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2023/11/23/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><hr><h2 id="理论篇"><a href="#理论篇" class="headerlink" title="理论篇"></a>理论篇</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>第一次接触KMP算法是在《大话数据结构》这本书上，算是这本书第一个有难度的部分，之后在B站上看了相关视频勉强弄了个半懂。昨天在Leetcode上再次刷到了KMP——<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 找出字符串中第一个匹配项的下标</a>，但是没法自己写出代码实现，于是又深入的学习了下如何手撕，这下算是完全懂了，主要参考的是<a href="https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a>对应题目的章节，这里我再按照自己的理解复述一遍。</p><h3 id="什么是KMP？"><a href="#什么是KMP？" class="headerlink" title="什么是KMP？"></a>什么是KMP？</h3><p>KMP这个名字来自于发明这个算法的三位学者的名字首字母：Knuth，Morris和Pratt。</p><h3 id="KMP主要解决了什么问题？"><a href="#KMP主要解决了什么问题？" class="headerlink" title="KMP主要解决了什么问题？"></a>KMP主要解决了什么问题？</h3><p>KMP主要解决字符串的子串匹配问题。</p><p>例如：查找字符串 <code>&quot;aabaabaafa&quot;</code> 中是否存在字符串 <code>&quot;aabaaf&quot;</code> 。</p><p>前一个字符串称为<strong>文本串</strong>，后一个字符串称为<strong>模式串</strong>。</p><p>遇到这样的问题，人们的第一反应往往是双层for循环遍历两个字符串来查找是否存在这样的字串（暴力），如果文本串的长度记为 <code>m</code> ，模式串的长度记为 <code>n</code> ，则算法的时间复杂度为 <code>O(mn)</code> 。</p><p>暴力解法当然可以解决字符串匹配问题，Leetcode的28题也可以用这样的方法Accept（AC），但是有没有时间复杂度更低的算法呢？</p><p>KMP算法给出了答案，<em><strong>KMP通过记录已经匹配的字符信息，达到避免重复回溯指针的目的</strong></em>，使算法的时间复杂度能够降低至 <code>O(m + n)</code> 。</p><p>那么如何记录已经匹配的字符信息呢？通过<strong>next数组</strong>。</p><p>在介绍next数组前必须先理清几个概念，何谓<strong>前缀</strong>？何谓<strong>后缀</strong>？何谓<strong>最长相等前后缀</strong>？何谓<strong>前缀表</strong>？</p><h3 id="什么是前缀后缀？"><a href="#什么是前缀后缀？" class="headerlink" title="什么是前缀后缀？"></a>什么是前缀后缀？</h3><p>字符串的<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>。</p><p>字符串的<strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。</p><p>例如，对于字符串 <code>“abba”</code>：</p><p>其前缀为 <code>&quot;a&quot;</code> 、 <code>&quot;ab&quot;</code> 、 <code>&quot;abb&quot;</code> 。</p><p>其后缀为 <code>&quot;bba&quot;</code> 、 <code>&quot;ba&quot;</code> 、 <code>&quot;a&quot;</code> 。</p><h3 id="什么是最长相等前后缀？"><a href="#什么是最长相等前后缀？" class="headerlink" title="什么是最长相等前后缀？"></a>什么是最长相等前后缀？</h3><p>有了前后缀的概念，最长相等前后缀就很容易理解了。</p><p><strong>最长相等前后缀的长度指对于某一字符串，它最大的相同前后缀长度为多少</strong>。</p><p>仍然以字符串 <code>&quot;abba&quot;</code> 为例，其最长相等前后缀为 <code>&quot;a&quot;</code>，最长相等前后缀的长度为1。（而不是2，因为子串 <code>“ab”</code> 不等于 <code>“bd”</code>）。</p><h3 id="什么是前缀表？如何计算前缀表？"><a href="#什么是前缀表？如何计算前缀表？" class="headerlink" title="什么是前缀表？如何计算前缀表？"></a>什么是前缀表？如何计算前缀表？</h3><p><strong>前缀表记录了模式串中当前下标位置之前的字符串（包括当前位置）的最长相等前后缀的长度数据</strong>。</p><p>光看这句话可能有点懵，下面以模式串 <code>&quot;aabaaf&quot;</code> 为例写一下它的前缀表。</p><table><thead><tr><th align="center">下标</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th></tr></thead><tbody><tr><td align="center">模式串</td><td align="center">a</td><td align="center">a</td><td align="center">b</td><td align="center">a</td><td align="center">a</td><td align="center">f</td></tr><tr><td align="center">前缀表</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">0</td></tr></tbody></table><p>首先将下标放置在第一个字符 <code>&quot;a&quot;</code> 上，此时下标为0，其“<em>当前下标位置之前的字符串（包括当前位置）</em>”为 <code>&quot;a&quot;</code> ，字符串 <code>&quot;a&quot;</code> 的前后缀都为空，因此最长相等前后缀为0，前缀表中下标为0的位置填入0。因此对于所有前缀表，其下标为0的位置都可以无脑填入0；</p><p>之后将下标放置在第二个字符 <code>&quot;a&quot;</code> 上，此时下标为0，其“<em>当前下标位置之前的字符串（包括当前位置）</em>”为 <code>&quot;aa&quot;</code> ，字符串 <code>&quot;aa&quot;</code> 的最长相等前后缀长度为1，前缀表中下标为1的位置填入1。</p><p>依次类推，我们可以看着模式串将前缀表填写完整。</p><h3 id="前缀表和next数组有什么关系？"><a href="#前缀表和next数组有什么关系？" class="headerlink" title="前缀表和next数组有什么关系？"></a>前缀表和next数组有什么关系？</h3><p>这是个困扰了我很久的问题，因为不同的人对next数组有不同的讲法。程杰在《大话数据结构》里给出的next数组和nextval数组我到现在都没看明白，各种考研辅导老师和视频里给出的next数组定义也很不统一，一会要统一减一，一会要右移第一个位置赋-1，绕的很晕。但是代码随想录的卡尔在他的<a href="https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E6%80%9D%E8%B7%AF">文章</a>和<a href="https://www.bilibili.com/video/BV1PD4y1o7nd">视频</a>里解释的很清楚，我再在这里陈述一遍。</p><p><em>next数组可以就是前缀表本身</em>，也可以是整体右移一位第一位赋值-1，还可以是整体减一（匹配的时候再把1加回来，神经病！）。无论采用何种next数组都只是KMP算法实现细节，不涉及原理性的东西。</p><p>所以在这里我们<strong>选择使next数组即为前缀表本身</strong>，这种方法更接近KMP的实现原理（前缀表），更方便我们去记忆。</p><h3 id="next数组（前缀表）有什么作用？"><a href="#next数组（前缀表）有什么作用？" class="headerlink" title="next数组（前缀表）有什么作用？"></a>next数组（前缀表）有什么作用？</h3><p>到现在为止我们已经掌握了一项技能，就是看着模式串写出前缀表，即写出next数组。</p><p>next数组之所以叫next，是因为当文本串指针与模式串指针所指字符不匹配时，可以根据next数组回溯模式串指针到新的位置来继续匹配，而不必总是回到模式串头位置。</p><h3 id="next数组（前缀表）为何能回溯模式串指针？"><a href="#next数组（前缀表）为何能回溯模式串指针？" class="headerlink" title="next数组（前缀表）为何能回溯模式串指针？"></a>next数组（前缀表）为何能回溯模式串指针？</h3><p>首先我们先看一下文本串 <code>&quot;aabaabaafa&quot;</code> 是如何查找模式串 <code>&quot;aabaaf&quot;</code> 的。</p><p><img src="/2023/11/23/KMP%E7%AE%97%E6%B3%95/image.png" alt="KMP匹配过程"></p><p>文本串指针和模式串指针分别从各自字符串的头部开始一一向后比较，前五个字符 <code>&quot;aabaa&quot;</code> 都能够匹配，此时移动到第六个字符发现不匹配，模式串指针由 <code>&quot;f&quot;</code> 回溯至 <code>&quot;b&quot;</code>，而文本串指针不动等待继续匹配。</p><p>到这一步，暴力（或称朴素）算法就要将文本串指针回溯到第二个字符，模式串指针回溯到第一个字符重新开始匹配了。KMP的优越性就体现出来了。</p><p>那么为什么模式串指针要从 <code>&quot;f&quot;</code> 回溯至 <code>&quot;b&quot;</code>呢？</p><table><thead><tr><th align="center">下标</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th></tr></thead><tbody><tr><td align="center">模式串</td><td align="center">a</td><td align="center">a</td><td align="center">b</td><td align="center">a</td><td align="center">a</td><td align="center">f</td></tr><tr><td align="center">前缀表</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">0</td></tr></tbody></table><p>以下这句话，对于理解为什么前缀表可以告诉我们匹配失败之后跳到哪里重新匹配，非常重要！</p><p><strong>下标5之前这部分的字符串（也就是字符串 <code>&quot;aabaa&quot;</code>）的最长相等的前缀和后缀字符串是子字符串aa，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。</strong></p><p>所以前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力。</p><p>但如果新的模式串所指字符依然与文本串指针所指字符不同又当如何呢？</p><p>那我们继续重复上述过程，当前模式串下标为2，查询next[2 - 1]的值为1，将模式串的指针回溯到下标为1的位置，即第二个字符 <code>&#39;a&#39;</code> 。</p><p>如果一直无法与文本串指针所指字符匹配（模式串指针指向下标0位），那么文本串指针向后移一位。</p><h3 id="KMP算法匹配过程总览"><a href="#KMP算法匹配过程总览" class="headerlink" title="KMP算法匹配过程总览"></a>KMP算法匹配过程总览</h3><p><img src="/2023/11/23/KMP%E7%AE%97%E6%B3%95/image-2.png" alt="KMP算法匹配过程总览"></p><p>这下我们大概了解了KMP的匹配过程，再来回顾一下。</p><ol><li>首先我们需要根据模式串写出next数组（前缀表）。</li><li>之后我们让<strong>文本串指针i</strong>与<strong>模式串指针j</strong>同时从各字符串头部开始向后遍历。</li><li>一旦遇到字符不匹配的情况我们根据next[j - 1]的值将模式串指针j回溯到对应的下标位置，而文本串指针i不做变化。直到找到新的能够匹配的模式串指针，则继续向后匹配；或者j回溯到0位也没有遇到能匹配i所指的字符，那么文本串指针i向后移一位（++i）重新匹配。</li><li>如果循环到某个位置，模式串的所有字符都匹配完成了，则表示能够在文本串中找到对应子串；反之，若文本串指针i走到文本串的末尾也没能匹配完所有的模式串字符，则表示不能在文本串中找到对应子串。</li></ol><p>至此大功告成！</p><h3 id="KMP算法的时间复杂度分析"><a href="#KMP算法的时间复杂度分析" class="headerlink" title="KMP算法的时间复杂度分析"></a>KMP算法的时间复杂度分析</h3><p>如果文本串的长度记为 <code>m</code> ，模式串的长度记为 <code>n</code>。</p><p>在最差情况下（模式串在文本串的末尾才能被匹配），暴力的双for循环时间复杂度为 <code>O(mn)</code> 。</p><p>而KMP只需要遍历一次文本串<code>O(m)</code>和生成next数组<code>O(n)</code>，总的时间复杂度为<code>O(m + n)</code> 。</p><p>因此KMP算法可以极大地提高检索效率。</p><hr><h2 id="代码篇"><a href="#代码篇" class="headerlink" title="代码篇"></a>代码篇</h2>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode59.螺旋矩阵 II</title>
    <link href="/2023/11/20/Leetcode59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II/"/>
    <url>/2023/11/20/Leetcode59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II/</url>
    
    <content type="html"><![CDATA[<h1 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a>59. 螺旋矩阵 II</h1><p>给你一个正整数 <code>n</code> ，生成一个包含 1 到 $n^2$ 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 matrix 。</p><p><strong>示例 1：</strong><br><img src="/2023/11/20/Leetcode59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II/image.png" alt="Alt text"></p><p><strong>输入：</strong> n &#x3D; 3<br><strong>输出：</strong> [[1,2,3],[8,9,4],[7,6,5]]</p><p><strong>示例 2：</strong><br><strong>输入：</strong> n &#x3D; 1<br><strong>输出：</strong> [[1]]</p><p><strong>提示：</strong></p><p>· 1 &lt;&#x3D; n &lt;&#x3D; 20</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>初始化一个 <code>n×n</code> 大小的矩阵 <code>mat</code>，然后模拟整个向内环绕的填入过程：</p><p>1.定义当前左右上下边界 <code>l,r,t,b</code>，初始值 <code>num = 1</code>，迭代终止值 <code>tar = n * n</code>；</p><p>2.当 <code>num &lt;= tar</code> 时，始终按照从左到右、从上到下、从右到左、从下到上的填入顺序循环，每次填入后：<br>    a.执行 <code>num += 1</code>：得到下一个需要填入的数字；<br>    b.更新边界：例如从左到右填完后，上边界 <code>t += 1</code>，相当于上边界向内缩1。</p><p>3.使用<code>num &lt;= tar</code>而不是<code>l &lt; r || t &lt; b</code>作为迭代条件，是为了解决当n为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。</p><p>4.最终返回 <code>mat</code> 即可。</p><p><img src="/2023/11/20/Leetcode59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II/image-1.png" alt="Alt text"></p><p>作者：Krahets<br>链接：<a href="https://leetcode.cn/problems/spiral-matrix-ii/solutions/12594/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/">https://leetcode.cn/problems/spiral-matrix-ii/solutions/12594/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>, l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>, b = n - <span class="hljs-number">1</span>; <span class="hljs-comment">//定义初始上、左、右、下边界</span><br>        <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">res</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n)); <span class="hljs-comment">//定义一个二维vector存储结果</span><br>        <span class="hljs-keyword">while</span> (num &lt;= n * n) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; ++i) res[t][i] = num++;<br>            ++t; <span class="hljs-comment">//上边界下移</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = t; i &lt;= b; ++i) res[i][r] = num++;<br>            --r; <span class="hljs-comment">//右边界左移</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r; i &gt;= l; --i) res[b][i] = num++;<br>            --b; <span class="hljs-comment">//下边界上移</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = b; i &gt;= t; --i) res[i][l] = num++;<br>            ++l; <span class="hljs-comment">//左边界右移</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看起来边界条件复杂的一道题目，经过K神的简化能写得如此清晰、优美，着实让人五体投地。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图灵停机问题</title>
    <link href="/2023/11/20/%E5%9B%BE%E7%81%B5%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98/"/>
    <url>/2023/11/20/%E5%9B%BE%E7%81%B5%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个问题来自于我前两天看的一个视频<a href="https://www.bilibili.com/video/BV1EW411u7th">【计算机科学速成课】</a> P15阿兰·图灵一节。小姐姐把问题阐述的很清楚，但即使有动画图解我仍然无法理解证明方法。以下给出我在知乎上看到一个答主给的<a href="https://zhuanlan.zhihu.com/p/653811654">总结</a>。</p><h1 id="1-何谓“停机问题”？"><a href="#1-何谓“停机问题”？" class="headerlink" title="1. 何谓“停机问题”？"></a>1. 何谓“停机问题”？</h1><p><strong>给定图灵机描述和输入，是否有算法可以确定机器会永远计算下去（死循环）还是会到某一时刻停机？</strong></p><p>一个例子就是如果我写了一个程序，是否可以通过某一程序事先确定我写的程序是会陷入死循环还是能够正常结束？</p><p>答案是否定的，以下是反证法的证明。</p><h1 id="2-停机自动判定程序H"><a href="#2-停机自动判定程序H" class="headerlink" title="2. 停机自动判定程序H"></a>2. 停机自动判定程序H</h1><p>为了沟通方便，事先约定如下：</p><p>设一个程序为P，运行时需要传入一个参数，若要运行它，则这么表示：</p><p><code>P(参数)</code></p><p>而如果想强调这一程序的代码本身，则记为：</p><p><code>[P]</code></p><p>停机自动判定程序记作H，它应该有两个参数。参数1：待判定程序P；参数2：运行P程序时的传入参数。（对于某个需要参数的程序P，不能单纯地说它会不会停机。有可能传入101时会停机，而传入42后又陷入死循环了，所以传入参数不能省略。）</p><p>所以，以下给出H的使用范例：</p><p>如果P(42)会死循环不停机，那么H([P], 42)返回false；</p><p>如果P(“apple”)会停机，那么H([P], “apple”)返回true。</p><h1 id="3-反证法"><a href="#3-反证法" class="headerlink" title="3. 反证法"></a>3. 反证法</h1><p>图灵首先定义了一个跟H对着干的程序U，代码如下：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs wren">定义程序 <span class="hljs-title function_">U</span>(参数)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">H</span>(参数, 参数) <span class="hljs-operator">==</span> <span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;&#125; <span class="hljs-comment">//死循环</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简略解释以下，如果停机自动判定程序H返回true，那么就让程序U陷入死循环；如果H返回false，那就返回true。</p><p>那么如果将U的代码数据传入U中，那么就变成了：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs wren">定义程序 <span class="hljs-title function_">U</span>([<span class="hljs-params">U</span>])<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">H</span>([<span class="hljs-variable">U</span>], [<span class="hljs-variable">U</span>]) <span class="hljs-operator">==</span> <span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;&#125; <span class="hljs-comment">//死循环</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-分析"><a href="#4-分析" class="headerlink" title="4. 分析"></a>4. 分析</h1><p>① H([U], [U])返回true意味着，停机自动判定程序H认为U([U])这个程序能够正常停机。但如果程序U([U])进入了当前的if分支则会陷入死循环而无法正常停机，矛盾！</p><p>② H([U], [U])返回false意味着，停机自动判定程序H认为U([U])这个程序会陷入死循环。同理，如果程序U([U])进入了当前的else分支则会返回true正常停机，再次矛盾！</p><p>双重矛盾表明，“停机自动判定程序H”根本不存在。</p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>停机问题的反证法很巧妙，精髓在于想出来<code>U(参数)</code>和<code>H(参数, 参数)</code>的互相转换和<code>[U]</code>的代入。</p>]]></content>
    
    
    <categories>
      
      <category>计算机科学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《Essential C++》读书笔记</title>
    <link href="/2023/09/22/%E3%80%8AEssential%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/09/22/%E3%80%8AEssential%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Lippman在前言部分明确的阐明了本书的写作目的：“C++ Primer第三版其实无法扮演人们在初学C++时的导师角色。它太庞大了”。</p><h2 id="结构与组织"><a href="#结构与组织" class="headerlink" title="结构与组织"></a>结构与组织</h2><p>结构与组织部分可能很好的说明了此书的组织架构，但我现在还看不懂，就先不重复了。之后会讲每一部分的内容附加到相应章节之前。</p><h2 id="关于源代码"><a href="#关于源代码" class="headerlink" title="关于源代码"></a>关于源代码</h2><p>本书所有的程序，以及习题解答中的完整代码，都可以从网上获得。可以在<a href="https://www.informit.com/store/essential-c-plus-plus-9780201485189">Addison Wesley的网站</a>或<a href="http://www.broadview.com.cn/book/4437">博文视点网站</a>取得。</p><h1 id="第1章-C-编程基础"><a href="#第1章-C-编程基础" class="headerlink" title="第1章 C++编程基础"></a>第1章 C++编程基础</h1><p>第1章借着撰写一个具有互动性质的小程序，描绘C++语言预先定义的部分。这一章涵盖了内置的数据类型、语言预定义的运算符（operator）、标准库中的<em>vector</em>和<em>string</em>、条件语句和循环语句、输入和输出用的iostream库。</p><h2 id="1-1-如何撰写C-程序"><a href="#1-1-如何撰写C-程序" class="headerlink" title="1.1 如何撰写C++程序"></a>1.1 如何撰写C++程序</h2><ul><li><p>每个C++程序都是从一个名为<strong>main</strong>的函数开始执行，其通用形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>习惯上，程序执行无误时我们令main()返回零。若返回一个非零值，表示程序在执行过程中发生了错误。</p></li><li><p>C++标准的“输入&#x2F;输出库”名为iostream，用以支持对终端和文件的输入与输出。</p></li><li><p>如果没有在main()的末尾写下return语句，<code>return 0</code>将会被自动加上。</p></li><li><p>第一个完整的C++程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">string</span> user_name;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Please enter your first name:&quot;</span>;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; user_name;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span> &lt;&lt; <span class="hljs-string">&quot;Hello, &quot;</span> &lt;&lt; user_name &lt;&lt; <span class="hljs-string">&quot; ... and goodbye!\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="1-2-对象的定义和初始化"><a href="#1-2-对象的定义和初始化" class="headerlink" title="1.2 对象的定义和初始化"></a>1.2 对象的定义和初始化</h2><ul><li>对象的名称可以是任何字母、数字、下划线（underscore）的组合。</li><li>对象的名称不能以数字开头。</li><li>任何命名不能和程序语言本身的关键字一致。</li><li>const关键字用来表示常量的对象。</li></ul><h2 id="1-3-撰写表达式"><a href="#1-3-撰写表达式" class="headerlink" title="1.3 撰写表达式"></a>1.3 撰写表达式</h2><ul><li>四种运算符：算术运算符、关系运算符、逻辑运算符、复合赋值运算符</li><li>条件运算符的一般形式：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">expr</span><br>    ? 如果<span class="hljs-built_in">expr</span>为<span class="hljs-literal">true</span>，就执行这里<br>    : 如果<span class="hljs-built_in">expr</span>为<span class="hljs-literal">false</span>，则执行这里<br></code></pre></td></tr></table></figure></li><li>OR逻辑运算符（||）可以同时检验多个表达式的结果。左侧表达式会被先求值，如果其值为<code>true</code>，剩下的另一个表达式就不需要再被求值（此所谓<strong>短路求值法</strong>）。</li></ul><h3 id="运算符优先级（优先级从上到下）"><a href="#运算符优先级（优先级从上到下）" class="headerlink" title="运算符优先级（优先级从上到下）"></a>运算符优先级（优先级从上到下）</h3><ol><li>逻辑运算符NOT</li><li>算术运算符（*, &#x2F;, %）</li><li>算术运算符（+, -）</li><li>关系运算符（&lt;, &gt;, &lt;&#x3D;, &gt;&#x3D;）</li><li>关系运算符（&#x3D;&#x3D;, !&#x3D;）</li><li>逻辑运算符AND</li><li>逻辑运算符OR</li><li>赋值运算符</li></ol><ul><li>如果想要改变内置的运算符优先级，可利用小括号。</li><li>运算优先级是C++变成之所以复杂的原因之一。</li></ul><h2 id="1-4-条件语句和循环语句"><a href="#1-4-条件语句和循环语句" class="headerlink" title="1.4 条件语句和循环语句"></a>1.4 条件语句和循环语句</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><ul><li>switch语句中break的用途：当某个标签和switch表达式值吻合时，该case标签之后的所有case标签也都会被执行，除非我们明确使用break来结束执行。</li></ul><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h2 id="1-5-如何运用Array和Vector"><a href="#1-5-如何运用Array和Vector" class="headerlink" title="1.5 如何运用Array和Vector"></a>1.5 如何运用Array和Vector</h2><ul><li>一般建议使用vector甚于array。</li><li>array和vector之间存在一点差异，那就是vector知道自己的大小是多少。（vector.size()）</li></ul><h2 id="1-6-指针带来弹性"><a href="#1-6-指针带来弹性" class="headerlink" title="1.6 指针带来弹性"></a>1.6 指针带来弹性</h2><ul><li>指针主要做两件事，它可以增加程序本身的弹性，但同时增加了直接操作对象时所没有的复杂度。</li><li>下述写法可以将<code>pi</code>的初值设置为<code>ival</code>所在的内存地址<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *pi = &amp;ival<br></code></pre></td></tr></table></figure></li><li>提领（dereference）操作——就是取得“位于该指针所指内存地址上”的对象。在指针之前使用<code>*</code>号，便可以达到这个目的。</li><li>指针的复杂度源于它的双重性质：既可以操作指针包含的内存地址，又可以操作指针所指的对象值。</li><li>指针第二个可能令人感到复杂的地方是：在使用指针时，必须在提领之前确定它的确指向某对象。</li><li>一个未指向任何对象的指针，其地址值为0。有时候我们称之为null指针。</li><li>如果要通过指针来选择操作，必须用arrow（-&gt;）而非dot（.）成员选择运算符。</li></ul><h2 id="1-7-文件的读写"><a href="#1-7-文件的读写" class="headerlink" title="1.7 文件的读写"></a>1.7 文件的读写</h2><ul><li>要对文件进行读写操作，首先得包含fstream文件。</li></ul><h1 id="第2章-面向过程的编程风格"><a href="#第2章-面向过程的编程风格" class="headerlink" title="第2章 面向过程的编程风格"></a>第2章 面向过程的编程风格</h1><p>第2章解释函数的设计与使用，并逐一查看C++函数的多种不同风貌，包括inline函数、重载（<em>overloaded</em>）函数、function template，以及函数指针（pointers to <em>functions</em>）。</p><h2 id="2-1-如何编写函数"><a href="#2-1-如何编写函数" class="headerlink" title="2.1 如何编写函数"></a>2.1 如何编写函数</h2><ul><li>每一个函数必须定义以下四个部分：<ol><li>返回类型</li><li>函数名</li><li>参数列表</li><li>函数体</li></ol></li><li>函数必须先被声明，然后才能被调用（被使用）。函数声明不必提供函数体，但必须明确返回类型、函数名，以及参数列表。</li></ul><h2 id="2-2-调用函数"><a href="#2-2-调用函数" class="headerlink" title="2.2 调用函数"></a>2.2 调用函数</h2><ul><li><strong>冒泡排序</strong>：由两个嵌套的for循环实现。外层的for循环一次以ix为索引遍历vector内的元素，其值由0递增至size-1；内层的for循环以jx为索引从ix+1依次递增至size-1；并且同时比较vector中ix和jx处两元素的值，如果jx处的元素小则将其互换。</li><li>传值（pass by value）：当我们将vec[ix]这样的对象传入函数，默认情形下其值会被复制一份，成为参数的局部性定义（local definition）。</li><li>传址（pass by reference）：令函数的参数和传入的实际对象产生关联。要达成这个目的，最简单的做法就是将参数声明为一个reference。</li></ul><h3 id="Pass-by-Reference语义"><a href="#Pass-by-Reference语义" class="headerlink" title="Pass by Reference语义"></a>Pass by Reference语义</h3><ul><li>当我们以by reference的方式将对象作为函数参数传入时，对象本身并不会复制出另一份——复制的是对象的地址。</li><li>将参数声明为reference有两个理由：①希望的一直接对所传入的对象进行修改。②降低复制大型对象的负担。</li><li>一般来说，除非希望在函数内修改参数值，否则建议在传递内置类型时，不要使用传址方式。传址机制主要用于传递class object。</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul><li>除了一个必要的例外（static），函数内定义的对象，只存在于函数执行期间。</li><li>为对象分配的内存，其存活时间成为储存器（storage duration）或范围（extent）。</li><li>对象在程序内的存活区域成为该对象的作用域（scope）</li><li>对象如果在函数之外声明，则具有所谓的file scope。对象如果拥有file scope，从其声明点至文件末尾都是可见的。</li><li>内置类型的对象，如果定义在file scope内，必定被初始化为0。但如果它们被定义于local scope之内，那么除非程序员指定其初值，否则不会被初始化。</li></ul><h3 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h3><ul><li>除了local scope和file scope，还有一种储存其形式成为dynamic extent（动态范围）。其内存有程序的空闲空间（free store）分配而来，有时也称为heap memory（堆内存）。这种内存必须由程序员自行管理，其分配通过new来完成，释放通过delete表达式完成。</li><li>由于某种原因，程序员不想使用delete表达式，由heap分配而来的对象就永远不会被释放，这称为内存泄漏（memory leak）。</li></ul><h2 id="2-3提供默认参数"><a href="#2-3提供默认参数" class="headerlink" title="2.3提供默认参数"></a>2.3提供默认参数</h2><ul><li>默认参数值的提供有两个不直观的规则：<ol><li>默认值的解析（resolve）操作由最右边开始进行。如果我们为某个参数提供了默认值，那么这一参数右侧的所有参数都必须也具有默认参数才行。下面这样实属非法：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//错误：没有为vec提供默认值</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">( ostream &amp;os = <span class="hljs-built_in">cout</span>, <span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; &amp;vec)</span>;<br></code></pre></td></tr></table></figure></li><li>默认值只能指定一次，可以在声明处，亦可在函数定义处，但不能够在两个地方都指定。（头文件可为函数带来更高的可见性（visibility）为了更高的可见性，我们决定将默认值放在函数声明处而非定义处。）</li></ol></li></ul><h2 id="2-4-使用局部静态对象"><a href="#2-4-使用局部静态对象" class="headerlink" title="2.4 使用局部静态对象"></a>2.4 使用局部静态对象</h2><ul><li>为了节省函数见的通信问题而将对象定义于file scope中，永远都是一种冒险。通常，file scope对象会打乱不同函数间的独立性，使它们难以理解。</li><li>局部静态对象所处的内存空间，即使在不同的函数调用过程中，依然持续存在，这也就是我们可以安全地返回其地址的原因。</li></ul><h2 id="2-5-声明inline函数"><a href="#2-5-声明inline函数" class="headerlink" title="2.5 声明inline函数"></a>2.5 声明inline函数</h2><ul><li>将函数声明为inline，表示要求编译器在每个函数调用点上，将函数内容展开。面对一个inline函数，编译器可将该函数的调用操作改为以一份函数代码副本代替。这将是我们获得性能改善，其结果是把多个函数写入一个函数中，但依然维持三个独立的运算单元。</li><li>一般而言，最适合声明为inline1的函数具有如下特征：体积小、常被调用、所从事的计算并不复杂。</li><li>inline函数的定义常被放在头文件中。</li></ul><h2 id="2-6-提供重载函数"><a href="#2-6-提供重载函数" class="headerlink" title="2.6 提供重载函数"></a>2.6 提供重载函数</h2><ul><li><strong>函数函数</strong>：参数列表（parameter list）不相同（可能是参数类型不同，可能是参数个数不同）的两个或多个函数，可以拥有相同的函数名称。</li><li>编译器无法根据函数返回类型来区分两个具有相同名称的函数。</li><li>将一组实现代码不同但工作内容相似的函数加以重载，可以让用户更容易使用这些函数。如果没有重载机制，我们就得为每个函数提供不同的名称。</li></ul><h2 id="2-7-定义并使用模板函数"><a href="#2-7-定义并使用模板函数" class="headerlink" title="2.7 定义并使用模板函数"></a>2.7 定义并使用模板函数</h2><ul><li><strong>函数模板</strong>（function template）的机制：将单一函数的内容与希望显示的各种类型绑定（bind）起来。</li><li>一般而言，如果函数具备多种实现方式，我们可将它重载（overload），其每份实力提供的是相同的通用服务。如果我们希望让程序代码的主体不变，仅仅改变其中用到的数据类型，可以通过function template达到目的。</li></ul><h2 id="2-8-函数指针带来更大的弹性"><a href="#2-8-函数指针带来更大的弹性" class="headerlink" title="2.8 函数指针带来更大的弹性"></a>2.8 函数指针带来更大的弹性</h2><ul><li>函数指针（pointer to function）必须指明其所指函数的返回类型及参数列表；函数的定义必须将*放在某个位置，表示这份定义所表现的是一个指针；最后还必须给予一个名称。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;* (*seq_ptr)( <span class="hljs-type">int</span> );<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-9-设定头文件"><a href="#2-9-设定头文件" class="headerlink" title="2.9 设定头文件"></a>2.9 设定头文件</h2><ul><li>函数的定义只能有一份。</li><li>但上述规则有一个例外——inline函数的定义。为了能够扩展inline函数的内容，在每个调用点上，编译器都得取得其定义。这意味着我们必须将inline函数的定义放在头文件中，而不是把它放在不同的程序代码文件中。</li><li>在file scope内定义的对象，如果可能被多个文件访问，就应该被声明于头文件中。</li><li>下述对象的声明并不完全正确：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> seq_cnt = <span class="hljs-number">6</span>;<br><span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;* (*seq_array[seq_cnt])( <span class="hljs-type">int</span> );<br></code></pre></td></tr></table></figure>  需要在<code>seq_array</code>定义前加上关键字<code>extern</code>，便成为一个声明  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> seq_cnt = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;* (*seq_array[seq_cnt])( <span class="hljs-type">int</span> );<br></code></pre></td></tr></table></figure></li><li>为什么上述代码块中的<code>seq_cnt</code>不需要extern修饰？<br>因为const object和inline函数一样，是“一次定义”规则下的例外。const object的定义只要一处文件之外便不可见。</li><li>引用头文件何时使用<code>&lt;&gt;</code>何时使用<code>&quot;&quot;</code>包裹？<br>如果头文件和包含此文件的程序代码文件位于同一个磁盘目录下，便用<code>&quot;&quot;</code>。否则，用<code>&lt;&gt;</code>。</li></ul><h1 id="第3章-泛型编程风格"><a href="#第3章-泛型编程风格" class="headerlink" title="第3章 泛型编程风格"></a>第3章 泛型编程风格</h1><p>第3章涵盖了所谓的Standard Template Library（STL）：一组容器类（包括vector、list、set、map，等等）、一组作用于容器上的泛型算法（包括sort()、copy()、merge()，等等）。附录B按字典顺序列出了最广为运用的泛型算法，并逐一列上了使用实例。</p><ul><li>泛型算法提供了许多可作用于容器类及数组类型上的操作。这些算法之所以被称为泛型（generic），是因为它们和它们想要操作的元素类型无关。</li></ul><h2 id="3-1-指针的算术运算"><a href="#3-1-指针的算术运算" class="headerlink" title="3.1 指针的算术运算"></a>3.1 指针的算术运算</h2><ul><li>数组最后一个元素的下一个地址，扮演者我们所说的标兵的角色，用以指示我们的迭代操作何时完成。</li><li>指针的算术运算并不适用于list，因为指针的算术运算必须首先假设所有元素都储存在连续空间里，然后才能根据当前的指针，加上元素大小之后，指向下一个元素。</li></ul><h2 id="3-2-了解Iterator（泛型指针）"><a href="#3-2-了解Iterator（泛型指针）" class="headerlink" title="3.2 了解Iterator（泛型指针）"></a>3.2 了解Iterator（泛型指针）</h2><ul><li>如何取得iterator？<br>  每个标准容器都提供有一个名为begin()的操作函数，可返回一个iterator，指向第一个元素。另一个名为end()的操作函数会返回一个iterator，指向最后一个元素的下一个位置。因此，不论如何定义iterator对象，一下都是对iterator进行赋值（assign）、比较（compare）、递增（increment）、提领（dereference）操作：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (iter = svec.<span class="hljs-built_in">begin</span>(); iter != svec.<span class="hljs-built_in">end</span>(); ++iter)<br>    cout &lt;&lt; *iter &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br></code></pre></td></tr></table></figure></li><li>iterator的定义形式：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; svec;<br>vector&lt;string&gt;::iterator iter = svec.<span class="hljs-built_in">begin</span>();<br></code></pre></td></tr></table></figure>  此处iter被定义为一个iterator，指向一个vector，后者的元素类型为string。其初值指向svec的第一个元素。双冒号表示此iterator乃是位于string vector定义内的嵌套[<em>nested</em>]类型。</li><li>如果要通过iter调用底部的string元素所提供的操作，我们可以使用arrow（箭头）运算符：<br>  <code>cout &lt;&lt; &quot;(&quot; &lt;&lt; iter-&gt;size() &lt;&lt; &quot;):&quot; &lt;&lt; *iter &lt;&lt; endl;</code></li></ul><h2 id="3-3-所有容器的共通操作"><a href="#3-3-所有容器的共通操作" class="headerlink" title="3.3 所有容器的共通操作"></a>3.3 所有容器的共通操作</h2><p>下列为所有容器类（包括string类）的共通操作：</p><ul><li>equality (&#x3D;&#x3D;) 和inequality (!&#x3D;) 运算符，返回true或false。</li><li>assignment (&#x3D;)运算符，将某个容器复制给另一个容器。</li><li>empty()会在容器无任何元素时返回true，否则返回false。</li><li>size()返回容器内目前持有的元素个数。</li><li>clear()删除所有元素。</li></ul><h2 id="3-4-使用顺序性容器"><a href="#3-4-使用顺序性容器" class="headerlink" title="3.4 使用顺序性容器"></a>3.4 使用顺序性容器</h2><ul><li>顺序型容器用来维护一组排列有序、类型相同的元素。</li><li>vector用一块连续内存来存放元素。随机访问颇有效率，但插入或删除非末位元素缺乏效率。</li><li>list系以双向链接（double-linked）而非连续内存来存储内容。任意位置插入或删除颇有效率，随机访问缺乏效率。</li><li>deque（读作deck）和vector一样用连续内存存储元素。不同的是其两端插入和删除的效率都很高。</li><li>vector允许末端插入（push_back()）和删除(pop_back())操作。list和deque在此基础上允许前端插入（push_front()）和删除（pop_front()）。</li><li>list不支持iterator偏移运算：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//错误：list并不支持iterator偏移运算</span><br>list.<span class="hljs-built_in">erase</span>(it1, it1+num_tries);<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-5-使用泛型算法"><a href="#3-5-使用泛型算法" class="headerlink" title="3.5 使用泛型算法"></a>3.5 使用泛型算法</h2><ul><li>以下为四种常用的泛型搜索算法：<ol><li>find（）用于搜索无序集合中是否存在某值。</li><li>binary_search()用于有序集合的搜索。（效率比find()高）</li><li>count()返回数值相符的元素数目。</li><li>search()比对某个容器内是否存在某个子序列。</li></ol></li><li>binary_search()要求其作用对象必须经过排序（sorted）。</li></ul><h2 id="3-6-如何设计一个泛型算法"><a href="#3-6-如何设计一个泛型算法" class="headerlink" title="3.6 如何设计一个泛型算法"></a>3.6 如何设计一个泛型算法</h2><h3 id="Function-Object"><a href="#Function-Object" class="headerlink" title="Function Object"></a>Function Object</h3><ul><li>所谓function object是某种class的实例对象，这类class对function call运算符做了重载操作，这样一来可使function object被当成一般函数来使用。</li><li>function object实现了我们原本可能以独立函数加以定义的事物。但何必如此？主要是为了效率。我们可以令call运算符称为inline，从而消除“通过函数指针来调用函数”时付出的额外代价。</li><li><code>&lt;functional&gt;</code>标准库事先定义了一组function object，分为算术运算（arithmetic）、关系运算符（relational）和逻辑运算（logical）三大类：<ol><li>六个算术运算：<code>plus&lt;type&gt;</code>，<code>minus&lt;type&gt;</code>，<code>negate&lt;type&gt;</code>，<code>multiplies&lt;type&gt;</code>，<code>divides&lt;type&gt;</code>，<code>modules&lt;type&gt;</code>。</li><li>六个关系运算：<code>less&lt;type&gt;</code>，<code>less_equal&lt;type&gt;</code>，<code>greater&lt;type&gt;</code>，<code>greater_equal&lt;type&gt;</code>、<code>equal_to&lt;type&gt;</code>，<code>not_equal_to&lt;type&gt;</code>。</li><li>三个逻辑运算，分别对应&amp;&amp;、||、!运算符：<code>logical_and&lt;type&gt;</code>、<code>logical_or&lt;type&gt;</code>、<code>logical_not&lt;type&gt;</code>。</li></ol></li></ul><h3 id="Function-Object-Adapter"><a href="#Function-Object-Adapter" class="headerlink" title="Function Object Adapter"></a>Function Object Adapter</h3><ul><li>function object adapter会对function object进行修改操作。所谓<strong>binder adapter</strong>（绑定适配器）会将function object的参数绑定至特定值，使binary（二元）function object转化为unary（一元）function object。</li><li>标准库提供了两个binder adapter：<em>bind1st</em>会将指定值绑定至第一操作数，<em>bind2nd</em>则将指定值绑定至第二操作数。</li><li>另一种adapter是所谓的<strong>negator</strong>，它会对function object的真伪值取反。not1可对unary function object的真伪值取反，not2可对binary function object的真伪值取反。</li></ul><h2 id="3-7-使用Map"><a href="#3-7-使用Map" class="headerlink" title="3.7 使用Map"></a>3.7 使用Map</h2><ul><li>map被定义为一对（pair）数值，其中的key通常是个字符串，扮演索引的角色，另一个数值是value。</li><li>任何一个key值在map内最多只会有一份。如果我们需要储存多份相同的key值，就必须使用multimap。</li></ul><h2 id="3-8-使用Set"><a href="#3-8-使用Set" class="headerlink" title="3.8 使用Set"></a>3.8 使用Set</h2><ul><li>Set由一群key组合而成。如果我们想知道某值是否存在于某个集合内，就可以使用set。</li><li>默认情形下，set元素一句其所属类型默认的less-than运算符进行排列。例如，如果给定  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ia[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(ia, ia+<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">set_i</span><span class="hljs-params">(vec.begin(), vec.end())</span></span>;<br></code></pre></td></tr></table></figure>  <code>set_i</code>的元素将为{1,3,5,8}。</li><li>如果要为set加入单一元素，可使用单一参数的insert()。</li><li>如果要为set加入某一范围的元素，可使用双参数的insert()。</li></ul><h2 id="3-9-如何使用Iterator-Inserter"><a href="#3-9-如何使用Iterator-Inserter" class="headerlink" title="3.9 如何使用Iterator Inserter"></a>3.9 如何使用Iterator Inserter</h2><ul><li>标准库提供了三个所谓的<strong>insertion adapter</strong>，这些adapter让我们得以避免使用容器的assignment运算符：<ol><li>back_inserter()会以容器的push_back()函数取代assignment运算符。</li><li>inserter()会以容器的insert() 函数取代assignment运算符。</li><li>front_inserter()会以容器的push_front()函数取代assignment运算符。仅适用于list和deque。</li></ol></li><li>欲使用上述三种adapter，必须首先包含iterator头文件。</li><li>这些adapter不能用在array上，因为array不支持元素插入操作。</li></ul><h2 id="3-10-使用iostream-Iterator"><a href="#3-10-使用iostream-Iterator" class="headerlink" title="3.10 使用iostream Iterator"></a>3.10 使用iostream Iterator</h2><ul><li>标准库定义有供输入及输出使用的iostream iterator类，称为istream_iterator和ostream_iterator，分别支持单一类型的元素读取和写入。使用这两个iterator class之前，先得包含iterator头文件。</li><li>如果希望从文件中读取，写入文件中去。只需要将istream_iterator绑定至ifstream object，将ostream_iterator绑定至ofstream object即可。</li></ul><h1 id="第4章-基于对象的编程风格"><a href="#第4章-基于对象的编程风格" class="headerlink" title="第4章 基于对象的编程风格"></a>第4章 基于对象的编程风格</h1><ul><li>本章节将带你亲身了解class机制的设计与使用过程。在这个过程中，你会看到如何为自身的应用系统建立起专属的数据类型。</li><li>一般而言，class由两部分组成：一组公开的（public）操作函数和运算符，以及一组私有的（private）实现细节。</li><li>这些操作函数和运算符称为class的member function（成员函数），并代表这个class的公开接口。身为class用户，只能访问公开接口。</li><li>Class的private实现细节可由member function的定义以及与此class相关的任何数据组成。</li><li>Class用户通常不会关心细节的实现。身为一个用户，我们只利用其公开接口来进行编程。这种情形下，只要接口没有更改，即使实现细节重新打造，所有的应用程序代码也不需要变动。</li><li>这一章我们的境界将从class的使用提升至class的设计与实现。这正是C++程序员的主要工作。</li></ul><h2 id="4-1-如何实现一个Class"><a href="#4-1-如何实现一个Class" class="headerlink" title="4.1 如何实现一个Class"></a>4.1 如何实现一个Class</h2><ul><li>Class定义由两部分组成：class的声明，以及紧接着在声明之后的主体。主体部分由一对大括号括住，并以一对分号结尾。主题内的两个关键字public和private，用来标示每个块的“member访问权限”。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// public接口</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// private的实现部分</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li>所有member function必须在class主体内进行声明。如果在class主体内定义，这个member function会自动被视为<strong>inline</strong>函数。</li></ul><h2 id="4-2-什么是构造函数和解析函数"><a href="#4-2-什么是构造函数和解析函数" class="headerlink" title="4.2 什么是构造函数和解析函数"></a>4.2 什么是构造函数和解析函数</h2><ul><li><strong>构造函数</strong>（constructor）:编译器在每次class object被定义出来时使用的初始函数。</li><li>constructor的函数名必须与class名相同。语法规定，constructor不应指定返回类型，亦不用返回任何值。它可以被重载。</li><li>以下代码无法成功定义一个Triangular object：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Triangular <span class="hljs-title">t5</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>  因为C++必须兼容C。对C而言，t5之后带有小括号，会使t5被视为函数。</li></ul><h3 id="Member-Initialization-List（成员初始化列表）"><a href="#Member-Initialization-List（成员初始化列表）" class="headerlink" title="Member Initialization List（成员初始化列表）"></a>Member Initialization List（成员初始化列表）</h3><ul><li>Member initialization list紧接在参数列表最后的冒号后面，是个以逗号分隔的列表。其中，欲赋值给member的数值被放在member名称后面的小括号中；这使它们看起来像是在调用constructor。<em>Member initialization list主要用于将参数传给member class object的constructor</em>。</li><li><strong>析构函数</strong>（destructor）：一旦某个class提供有destructor，当其object结束生命时，便会自动调用destructor处理善后。Destructor主要用来释放在constructor中或对象生命周期中的资源。</li><li>Destructor的名称有严格的规定：class名称再加上’~’前缀。它绝不会有返回值，也没有任何参数。由于其参数列表为空，也不可能被重载。</li><li>Destructor并非绝对必要。事实上，C++编程的最难部分之一，便是了解何时需要定义destructor而何时不需要。</li></ul><h3 id="Memberwise-Initialization（成员逐一初始化）"><a href="#Memberwise-Initialization（成员逐一初始化）" class="headerlink" title="Memberwise Initialization（成员逐一初始化）"></a>Memberwise Initialization（成员逐一初始化）</h3><ul><li>默认情况下，当我们以某个class object作为另一个object的初值，class data member会被依次复制。此即所谓的Default Memberwise Initialization（默认成员逐一初始化）。</li><li>当我们设计class时，必须问问自己，在此class上进行“成员逐一初始化”的行为模式是否合适？如果答案是肯定的，我们就不需要另外提供copy constructor。否则，我们必须另行定义copy constructor。</li></ul><h2 id="4-3-何谓mutable（可变）和const（不变）。"><a href="#4-3-何谓mutable（可变）和const（不变）。" class="headerlink" title="4.3 何谓mutable（可变）和const（不变）。"></a>4.3 何谓mutable（可变）和const（不变）。</h2><ul><li>class设计者必须在member function身上标注const，以此告诉编译器：这个member function不会更改class object内容。</li><li>const修饰符必须在函数参数列表之后。</li><li>编译器会检查每个声明为const的member function，看看它们是否真的没有更改class object内容。</li></ul><h3 id="Mutable-Data-Member（可变的数据成员）"><a href="#Mutable-Data-Member（可变的数据成员）" class="headerlink" title="Mutable Data Member（可变的数据成员）"></a>Mutable Data Member（可变的数据成员）</h3><ul><li>关键字mutable可以让我们声明对某一变量的改变不会破坏class object的常量性。</li></ul><h2 id="4-4-什么是this指针"><a href="#4-4-什么是this指针" class="headerlink" title="4.4 什么是this指针"></a>4.4 什么是this指针</h2><ul><li>this指针系在member function内用来指向其调用者（一个对象）。</li></ul><h2 id="4-5-静态类成员"><a href="#4-5-静态类成员" class="headerlink" title="4.5 静态类成员"></a>4.5 静态类成员</h2><ul><li>static（静态）data member用来表示唯一的、可共享的member。它可以在同一类的所有对象中被访问。</li></ul><h3 id="Static-Member-Function（静态成员函数）"><a href="#Static-Member-Function（静态成员函数）" class="headerlink" title="Static Member Function（静态成员函数）"></a>Static Member Function（静态成员函数）</h3><ul><li>member function只有在“不访问任何non-static member”的条件下才能够被声明为static，声明方式是在声明之前加上关键字static。</li><li>当我们在class主体外定义member function时，无序重复加上关键字static（这个规则同样适用于static data member）。</li></ul><h2 id="4-6-打造一个Iterator-Class"><a href="#4-6-打造一个Iterator-Class" class="headerlink" title="4.6 打造一个Iterator Class"></a>4.6 打造一个Iterator Class</h2><ul><li>运算符重载的规则：<ul><li>不可以引入新的运算符。除了<code>..</code>、<code>.*</code>、<code>::</code>、<code>:?</code>四个运算符，其他的运算符皆可被重载。</li><li>运算符的操作数（operand）个数不可改变。</li><li>运算符的优先级（precedence）不可改变。</li><li>运算符函数的参数列表中，必须至少有一个参数为class类型。</li></ul></li><li>后置运算符重载必须提供一个int参数。</li></ul><h3 id="嵌套类型（Nested-Type）"><a href="#嵌套类型（Nested-Type）" class="headerlink" title="嵌套类型（Nested Type）"></a>嵌套类型（Nested Type）</h3><ul><li>一个类可以定义在另一个类的内部，前者称为嵌套类。（CSDN里要比书上讲的清晰的多）<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/Poo_Chai/article/details/91596538">[1]</span></a></sup></li><li>typedef可以为某个类型设定另一个不同的名称。其通用形式为  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> existing_type new_name;<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-7-合作关系必须建立在友谊的基础上"><a href="#4-7-合作关系必须建立在友谊的基础上" class="headerlink" title="4.7 合作关系必须建立在友谊的基础上"></a>4.7 合作关系必须建立在友谊的基础上</h2><ul><li>任何class都可以将其它function或class指定为朋友（friend）。而所谓<strong>friend</strong>，具备了让任何non-member function与class member function相同的访问权限，可以访问class的private member。</li></ul><h2 id="4-8-实现一个copy-assignment-operator"><a href="#4-8-实现一个copy-assignment-operator" class="headerlink" title="4.8 实现一个copy assignment operator"></a>4.8 实现一个copy assignment operator</h2><ul><li>只要class设计者明确提供了copy assignment operator，它就会被用来取代default memberwise copy行为。</li></ul><h2 id="4-9-实现一个function-object"><a href="#4-9-实现一个function-object" class="headerlink" title="4.9 实现一个function object"></a>4.9 实现一个function object</h2><ul><li>所谓<strong>function object</strong>乃是一种“提供有function call运算符”（<code>()</code>运算符的重载）的class。</li></ul><h2 id="4-10-重载iostream运算符"><a href="#4-10-重载iostream运算符" class="headerlink" title="4.10 重载iostream运算符"></a>4.10 重载iostream运算符</h2><ul><li>output运算符（<code>&lt;&lt;</code>）的重载。</li><li>input运算符（<code>&gt;&gt;</code>）的重载。</li></ul><h2 id="4-11-指针，指向Class-Member-Function"><a href="#4-11-指针，指向Class-Member-Function" class="headerlink" title="4.11 指针，指向Class Member Function"></a>4.11 指针，指向Class Member Function</h2><ul><li><strong>maximal munch编译规则</strong>：每个符号序列（symbol sequence）总是以“合法符号序列”中最长的哪个解释。</li><li>Pointer to member function和pointer to function的一个不同点是，前者必须通过同一类的对象加以调用，而该对象便是此member function内的this指针所指之物。</li></ul><h1 id="第5章-面向对象编程风格"><a href="#第5章-面向对象编程风格" class="headerlink" title="第5章 面向对象编程风格"></a>第5章 面向对象编程风格</h1><p>第5章介绍如何扩展class，使多个相关的class形成族系，支持面向对象的class层次体系。</p><h2 id="5-1-面向对象编程概念"><a href="#5-1-面向对象编程概念" class="headerlink" title="5.1 面向对象编程概念"></a>5.1 面向对象编程概念</h2><ul><li><strong>继承（inheritance）</strong>：使得我们将一群相关的类组织起来，并让我们得以分享其间的共通数据和操作行为。</li><li><strong>多态（polymorphism）</strong>：可以让我们在这些类上进行编程时，可以如同操控单一个体，而非相互独立的类，并赋予我们更多弹性来加入或移除任何特定类。</li><li>在C++中，父类被称为基类（base class），子类被称为派生类（derived class）。</li><li>多态（polymorphism）让基类的pointer或reference得以十分透明地（transparently）指向其任何一个派生类的对象。</li><li><strong>静态绑定（static binding）</strong>：程序执行之前就已解析出应该调用哪一个函数。</li><li><strong>动态绑定（dynamic binding）</strong>：“找出实际被调用的是哪一个派生类的目标函数”这一解析操作会延迟至运行时（run-time）才进行。</li></ul><h2 id="5-2-漫游：面向对象编程思维"><a href="#5-2-漫游：面向对象编程思维" class="headerlink" title="5.2 漫游：面向对象编程思维"></a>5.2 漫游：面向对象编程思维</h2><ul><li>默认情况下，member function的解析（resolution）皆在编译时静态地进行。若要令其在运行时动态进行，我们就得在它的声明前加上关键字virtual。</li><li>当程序定义出一个派生对象，基类和派生类的constructor都会被执行。（当派生对象被销毁，基类和派生类的destructor也都会被执行[<em>但次序颠倒</em>]。）</li></ul><h2 id="5-3-不带继承的多态"><a href="#5-3-不带继承的多态" class="headerlink" title="5.3 不带继承的多态"></a>5.3 不带继承的多态</h2><ul><li>面向对象编程模式消除了这种（不带继承的多态）方式的维护负担，使我们的程序得以精简，更具扩展性。</li></ul><h2 id="5-4-定义一个抽象基类"><a href="#5-4-定义一个抽象基类" class="headerlink" title="5.4 定义一个抽象基类"></a>5.4 定义一个抽象基类</h2><ul><li>定义抽象类的第一个步骤就是找出所有子类共通的操作行为。</li><li>设计抽象基类的下一步，便是设法找出哪些操作行为与类型相关（type-dependent）。这些操作行为应该成为整个类继承体系中的虚函数（virtual function）。</li><li>设计抽象基类的第三步，便是试着找出每个操作行为的访问层级（access level）。</li><li>每个虚函数，要么得有其定义，要么可设为“纯”虚函数（pure virtual function）——如果对于该类而言，这个虚函数并无实质意义的话，将虚函数赋值为0，意为它是一个纯虚函数。</li><li>根据一般规则，凡基类定义有一个（或多个）虚函数，应该将其destructor声明为virtual。</li></ul><h2 id="5-5-定义一个派生类"><a href="#5-5-定义一个派生类" class="headerlink" title="5.5 定义一个派生类"></a>5.5 定义一个派生类</h2><ul><li>派生类名称后紧跟冒号、关键字public，以及基类的名称。</li><li>派生类必须为从基类继承而来的每个纯虚数提供对应的实现。此外，它还必须声明其专属的member。</li><li>一般来说，继承而来的public和protected成员，不论在继承体系中深度如何，都可被视为派生类自身拥有的成员。</li></ul><h2 id="5-6-运用继承体系"><a href="#5-6-运用继承体系" class="headerlink" title="5.6 运用继承体系"></a>5.6 运用继承体系</h2><h2 id="5-7-基类应该多么抽象"><a href="#5-7-基类应该多么抽象" class="headerlink" title="5.7 基类应该多么抽象"></a>5.7 基类应该多么抽象</h2><ul><li>基类的另一种设计方式：将所有派生类共有的实现内容剥离出来移至基类中，接口仍旧没有变动。</li></ul><h2 id="5-8-初始化、析构、复制"><a href="#5-8-初始化、析构、复制" class="headerlink" title="5.8 初始化、析构、复制"></a>5.8 初始化、析构、复制</h2><ul><li>派生类的constructor，不仅必须为派生类的data member进行初始化操作，还需要为其基类的data member提供适当的值。</li></ul><h2 id="5-9-在派生类中定义一个虚函数"><a href="#5-9-在派生类中定义一个虚函数" class="headerlink" title="5.9 在派生类中定义一个虚函数"></a>5.9 在派生类中定义一个虚函数</h2><ul><li>当我们定义派生类时，我们必须决定，究竟要将基类中的虚函数覆盖掉，还是原封不动地加以继承。<ul><li>如果我们继承了纯虚函数（pure virtual function），那么这个派生类也会被视为抽象类，也就无法为它定义任何对象。</li><li>如果我们决定覆盖基类所提供的虚函数，那么派生类提供新的定义，其函数原型必须完全符合基类所声明的函数原型，包括：参数列表、返回类型、常量性（const-ness）。</li></ul></li><li>“返回类型必须完全吻合”这一规则有个例外——当基类的虚函数返回某个基类形式（通常是pointer或reference时），派生类的同名函数可以返回该基类所派生出来的类型。</li></ul><h3 id="虚函数的静态解析（Static-Resolution）"><a href="#虚函数的静态解析（Static-Resolution）" class="headerlink" title="虚函数的静态解析（Static Resolution）"></a>虚函数的静态解析（Static Resolution）</h3><ul><li>有两种情况，虚函数机制不会出现预期行为：<ol><li>基类的constructor和destructor内；</li><li>当我们使用的是基类对象，而非基类对象的pointer或reference时。</li></ol></li><li>为了能够“在单一对象中展现多种类型”，多态（polymorphism）需要一层间接性。在C++中，唯有用基类的pointer或reference才能够支持面向对象的编程概念。</li></ul><h2 id="5-10-运行时的类型鉴定机制"><a href="#5-10-运行时的类型鉴定机制" class="headerlink" title="5.10 运行时的类型鉴定机制"></a>5.10 运行时的类型鉴定机制</h2><ul><li>typeid运算符是所谓运行时类型鉴定机制（Run-Time Type Identification， RTTI）的一部分，由程序语言支持。它让我们得以查询多态化的class pointer或class reference，获得其所指对象的实际类型。</li><li>使用typeid运算符前，必须先包含头文件<code>&lt;typeinfo&gt;</code>。</li><li>typeid运算符会返回一个type_info对象，其中储存着与类型相关的种种信息。</li><li>static_cast可以进行强制转换，但有潜在威胁，因为编译器无法确认我们所进行的转换操作是否完全正确。</li><li>dynamic_cast也是一个RTTI运算符，它会进行运行时检验操作，检验强转对象是否为目标值。</li></ul><h1 id="第6章-以template进行编程"><a href="#第6章-以template进行编程" class="headerlink" title="第6章 以template进行编程"></a>第6章 以template进行编程</h1><ul><li>第6章的重头戏是class template，那是建立class时的一种先行描述，让我们得以将class用到的一个（或多个）数据类型或数据值，抽离并参数化。以vector为例，可能需要将其元素的类型加以参数化，而buffer的设计不仅得将元素类型参数化，还得将其缓冲区容量参数化。本章的行进路线围绕在二分树（binary tree）class template的实现上。</li><li>在数据结构中，所谓树（tree）乃是由节点（node，或谓vertice）以及连接不同节点的链接（link）组成。所谓二叉树，维护着每个节点与下层另两个节点间的两条链接，一般将此下层二节点称为左子节点（left child）和右子节点（right child）。最上层第一个节点称为根节点（root）。无论是左子节点或右子节点，都可能扮演另一颗“子树（subtree）”的根节点。一个节点如果不再有任何子节点，便称为叶节点（leaf）。</li></ul><h2 id="6-1-被参数化的类型"><a href="#6-1-被参数化的类型" class="headerlink" title="6.1 被参数化的类型"></a>6.1 被参数化的类型</h2><ul><li>template机制能帮助我们将类定义中“与类型相关（type-dependent）”和“独立于类型之外”的两部分分离开。</li></ul><h2 id="6-2-Class-Template的定义"><a href="#6-2-Class-Template的定义" class="headerlink" title="6.2 Class Template的定义"></a>6.2 Class Template的定义</h2><ul><li>在class scope运算符出现之后，其后所有东西都被视为位于class定义范围内。</li></ul><h2 id="6-3-Template类型参数的处理"><a href="#6-3-Template类型参数的处理" class="headerlink" title="6.3 Template类型参数的处理"></a>6.3 Template类型参数的处理</h2><ul><li>建议将所有的template类型参数视为“class类型”来处理，不要选择在constructor内初始化。这意味着我们会把它声明为一个const reference，而非以by value的方式传递。</li></ul><h2 id="6-4-实现一个Class-Template"><a href="#6-4-实现一个Class-Template" class="headerlink" title="6.4 实现一个Class Template"></a>6.4 实现一个Class Template</h2><ul><li>new表达式可以分解为两个操作：<ol><li>向程序的空闲空间（free store）请求内存。如果分配到足够的空间，就分配一个指针，指向新对象。</li><li>如果第一步成功，并且外界指定了一个初值，这个新对象便会以最适当的方式被初始化。</li></ol></li><li>二叉树中移除某值的一般算法是，以节点的右子节点取代节点本身，然后搬移左子节点，使它成为右子节点的左子树的叶节点。</li><li>声明一个reference to pointer，我们不但可以改变pointer本身，也可以改变由此pointer指向的对象。</li></ul><h2 id="6-5-一个以Function-Template完成的Output运算符"><a href="#6-5-一个以Function-Template完成的Output运算符" class="headerlink" title="6.5 一个以Function Template完成的Output运算符"></a>6.5 一个以Function Template完成的Output运算符</h2><h2 id="6-6-常量表达式与默认参数值"><a href="#6-6-常量表达式与默认参数值" class="headerlink" title="6.6 常量表达式与默认参数值"></a>6.6 常量表达式与默认参数值</h2><ul><li>Template参数并不是非得某种类型（type）不可。我们也可以用常量表达式（constant expression）作为template参数。</li><li>全局作用域（global scope）内的函数及对象，其地址也是一种常量表达式，因此也可以被拿来表达这一形式的参数。</li></ul><h2 id="6-7-以Template参数作为一种设计策略"><a href="#6-7-以Template参数作为一种设计策略" class="headerlink" title="6.7 以Template参数作为一种设计策略"></a>6.7 以Template参数作为一种设计策略</h2><ul><li>class template无法基于参数列表的不同而重载。</li></ul><h2 id="6-8-Member-Template-Function"><a href="#6-8-Member-Template-Function" class="headerlink" title="6.8 Member Template Function"></a>6.8 Member Template Function</h2><ul><li>Non-template class或class template内都可定义member template function。</li></ul><h1 id="第7章-异常处理"><a href="#第7章-异常处理" class="headerlink" title="第7章 异常处理"></a>第7章 异常处理</h1><p>第7章介绍了如何使用C++的异常处理机制（exception handling facility），并示范如何将它融入标准库所定义的异常体系中。</p><h2 id="7-1-抛出异常"><a href="#7-1-抛出异常" class="headerlink" title="7.1 抛出异常"></a>7.1 抛出异常</h2><ul><li>异常处理机制有两个主要成分：异常的鉴定与发出，以及异常的处理方式。</li><li>异常出现之后，正常程序的执行便被暂停（suspended）。与此同时，异常处理机制开始搜索程序中有能力处理这一异常的地点。异常被处理完毕之后，程序的执行便会继续（resume），从异常处理点接着执行下去。</li><li>所谓异常（<strong>exception</strong>）是某种对象。大部分时候，被抛出的异常都属于特定的异常类（也许形成一个继承体系）。我们只是令它得以储存某些必要数据，用以表示异常的性质，以便我们得以在不同程序的不同调用点上相互传递这些性质。</li></ul><h2 id="7-2-捕获异常"><a href="#7-2-捕获异常" class="headerlink" title="7.2 捕获异常"></a>7.2 捕获异常</h2><ul><li>我们可以利用单条或一连串的catch子句来捕获（catch）被抛出的异常对象。catch子句由三部分组成：关键字catch、小括号内的一个类型或对象、大括号内的一组语句（用以处理异常）。</li><li>异常对象的类型会被拿来逐一地和每个catch子句比对。如果类型符合，那么该catch子句的内容便会被执行。</li><li>有时候我们可能无法完成异常的完整处理。在记录信息之外，我们或许需要重新抛出（rethrow）异常，以寻求其它catch子句的协助，做进一步的处理。重新抛出时，只需要写下关键字throw即可。它只能出现于catch子句中。它会将捕获的异常对象再一次抛出，并由另一个类型吻合的catch子句接受处理。</li><li>如果我们想要捕获任何类型的异常，可以使用一网打尽（catch-all）的方式。只需在异常声明部分指定省略号（…）即可，像这样：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//捕获任何类型的异常</span><br><span class="hljs-built_in">catch</span>( ... )<br>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="7-3-提炼异常"><a href="#7-3-提炼异常" class="headerlink" title="7.3 提炼异常"></a>7.3 提炼异常</h2><ul><li>catch子句应该和try块相应而生。try块是以关键字try作为开始，然后是大括号内的一连串程序语句。catch子句放在try块的末尾，这表示如果try块内有任何异常发生，便由接下来的catch子句加以处理。</li><li>如果“函数调用链”不断地被解开，一直回到了main（）还是找不到合适的catch子句。C++规定，每个异常都应该被处理。因此，标准库提供的terminate()便被调用——其默认行为时是中断整个程序的执行。</li></ul><h2 id="7-4-局部资源管理"><a href="#7-4-局部资源管理" class="headerlink" title="7.4 局部资源管理"></a>7.4 局部资源管理</h2><ul><li><strong>Resource acquisition initialization（在初始化阶段即进行资源请求）</strong>：对对象而言，初始化操作发生在constructor中，资源的请求亦发生在constructor内。资源的释放则应在destructor内完成。在异常处理机制终结某个函数之前，C++保证，函数中的所有局部对象的destructor都会被调用。</li><li>auto_ptr是标准库提供的class template，它会自动删除通过new表达式分配的对象。使用它前，必须包含相应的memory头文件：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul><h2 id="7-5-标准异常"><a href="#7-5-标准异常" class="headerlink" title="7.5 标准异常"></a>7.5 标准异常</h2><ul><li>如果new表达式无法从程序的空闲空间（free store）分配到足够的内存，它会抛出bad_alloc异常对象。</li><li>标准库定义了一套异常类体系（exception class hierarchy），其根部是名为exception的抽象基类。</li><li>bad_alloc派生自exception基类。<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/Poo_Chai/article/details/91596538">https://blog.csdn.net/Poo_Chai&#x2F;article&#x2F;details&#x2F;91596538</a><br><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></li></ul>]]></content>
    
    
    <categories>
      
      <category>Essential C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Markdown All in One常用操作汇总（for Windows）</title>
    <link href="/2023/09/22/Markdown_All_in_One%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/"/>
    <url>/2023/09/22/Markdown_All_in_One%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E9%94%AE%E7%9B%98%E5%BF%AB%E6%8D%B7%E9%94%AE">键盘快捷键</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95">创建目录</a></li><li><a href="#%E5%88%97%E7%BC%96%E8%BE%91">列编辑</a></li><li><a href="#github-flavored-markdown">Github Flavored Markdown</a></li><li><a href="#%E5%85%B6%E5%AE%83">其它</a></li></ul><h1 id="键盘快捷键"><a href="#键盘快捷键" class="headerlink" title="键盘快捷键"></a>键盘快捷键</h1><ol><li><p>加粗（Bold）<code>Ctrl + B</code><br><img src="/2023/09/22/Markdown_All_in_One%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/toggle-bold-1.gif" alt="Alt text"></p></li><li><p>斜体（Italic）<code>Ctrl + I</code></p></li><li><p>任务列表快速选择 <code>Alt + C</code><br><img src="/2023/09/22/Markdown_All_in_One%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/check-task-list.gif"></p></li><li><p>删除线 <code>Alt + S</code></p></li><li><p>标题（升级）<code>Ctrl + Shift + ]</code></p></li><li><p>标题（降级）<code>Ctrl + Shift + [</code></p></li><li><p>数学环境 <code>Ctrl + M</code></p></li><li><p>预览 <code>Ctrl + Shift + V</code></p></li><li><p>侧边预览 <code>Ctrl + K V</code></p></li></ol><h1 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h1><ul><li>在VSCode命令面板中运行命令”Create Table of Contents”来插入一个新目录。(<code>Ctrl + T 输入&quot;&gt;Create Table of Contents&quot;</code>)</li><li>默认情况下，Table of Content（TOC）会自动更新。若要禁用，请更改<code>toc.updateOnSave</code>选项。</li><li>轻松添加&#x2F;更新&#x2F;删除章节编号<br><img src="/2023/09/22/Markdown_All_in_One%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/section-numbers.gif"></li></ul><h1 id="列编辑"><a href="#列编辑" class="headerlink" title="列编辑"></a>列编辑</h1><ol><li><img src="/2023/09/22/Markdown_All_in_One%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/on-enter-key.gif"></li><li><img src="/2023/09/22/Markdown_All_in_One%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/tab-backspace.gif"></li><li><img src="/2023/09/22/Markdown_All_in_One%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/fix-marker.gif"></li></ol><h1 id="Github-Flavored-Markdown"><a href="#Github-Flavored-Markdown" class="headerlink" title="Github Flavored Markdown"></a>Github Flavored Markdown</h1><ul><li>表格式化<br><img src="/2023/09/22/Markdown_All_in_One%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/table-formatter.gif"></li></ul><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><ul><li>在选定的文本上粘贴链接<br><img src="/2023/09/22/Markdown_All_in_One%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/paste-link.gif"></li></ul>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VSCode + Hexo实现本地图片上传</title>
    <link href="/2023/09/21/VSCode-Hexo%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/"/>
    <url>/2023/09/21/VSCode-Hexo%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在写第二篇博文（Markdown学习笔记）的时候遇到的一个问题，本地存储的图片部署后无法显示到网页上。为了解决这个问题需要做两处修改。</p><h1 id="一、修改VSCode默认图片存储位置-1"><a href="#一、修改VSCode默认图片存储位置-1" class="headerlink" title="一、修改VSCode默认图片存储位置[1]"></a>一、修改VSCode默认图片存储位置<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.cnblogs.com/xbotter/p/17528063.html">[1]</span></a></sup></h1><p>首先 <code>Ctrl</code> + <code>,</code> 打开VSCode的设置首选项。搜索“markdown image”，添加一个项-值对为：<code>**/*.md</code>, <code>$&#123;documentBaseName&#125;/$&#123;fileName&#125;</code>。保存并退出。</p><p><img src="/2023/09/21/VSCode-Hexo%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/image.png" alt="Alt text"></p><p>这样后续粘贴进VS文本框的图片将会存放在.md文件同级目录下的同名文件夹中，方便进行文件管理。</p><p><img src="/2023/09/21/VSCode-Hexo%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/image-1.png" alt="Alt text"></p><h1 id="二、安装hexo-asset-image插件-2"><a href="#二、安装hexo-asset-image插件-2" class="headerlink" title="二、安装hexo-asset-image插件[2]"></a>二、安装hexo-asset-image插件<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.jianshu.com/p/db02d775aed0">[2]</span></a></sup></h1><p>使用命令</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/CodeFalling/</span>hexo-asset-image --save<br></code></pre></td></tr></table></figure><p>安装hexo-asset-image插件</p><p><strong>Tips:</strong> 安装失败可以尝试使用cnpm安装。</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.cnblogs.com/xbotter/p/17528063.html">https://www.cnblogs.com/xbotter/p/17528063.html</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.jianshu.com/p/db02d775aed0">https://www.jianshu.com/p/db02d775aed0</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Markdown学习笔记</title>
    <link href="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了今后的博客写作，有必要系统的学习Markdown。此笔记是<a href="https://markdown.com.cn/">Markdown官方教程</a>的学习记录，目的是加深对Markdown中概念的记忆，在实践中增强对Markdown语法的熟练度。</p><h1 id="一、入门基础"><a href="#一、入门基础" class="headerlink" title="一、入门基础"></a>一、入门基础</h1><h2 id="Markdown是什么？"><a href="#Markdown是什么？" class="headerlink" title="Markdown是什么？"></a>Markdown是什么？</h2><p>Markdown 是一种轻量级的标记语言，可用于在纯文本文档中添加格式化元素。</p><h2 id="为什么要使用Markdown？"><a href="#为什么要使用Markdown？" class="headerlink" title="为什么要使用Markdown？"></a>为什么要使用Markdown？</h2><ul><li>Markdown 无处不在。StackOverflow、CSDN、掘金、简书、GitBook、有道云笔记、V2EX、光谷社区等。主流的代码托管平台，如 GitHub、GitLab、BitBucket、Coding、Gitee 等等，都支持 Markdown 语法，很多开源项目的 README、开发文档、帮助文档、Wiki 等都用 Markdown 写作。</li><li>Markdown 是纯文本可移植的。几乎可以使用任何应用程序打开包含 Markdown 格式的文本文件。如果你不喜欢当前使用的 Markdown 应用程序了，则可以将 Markdown 文件导入另一个 Markdown 应用程序中。这与 Microsoft Word 等文字处理应用程序形成了鲜明的对比，Microsoft Word 将你的内容锁定在专有文件格式中。</li><li>Markdown 是独立于平台的。你可以在运行任何操作系统的任何设备上创建 Markdown 格式的文本。</li><li>Markdown 能适应未来的变化。即使你正在使用的应用程序将来会在某个时候不能使用了，你仍然可以使用文本编辑器读取 Markdown 格式的文本。当涉及需要无限期保存的书籍、大学论文和其他里程碑式的文件时，这是一个重要的考虑因素。</li></ul><h2 id="工欲善其事，必先利其器"><a href="#工欲善其事，必先利其器" class="headerlink" title="工欲善其事，必先利其器"></a>工欲善其事，必先利其器</h2><p>我选择 VSCode + Markdown All in One。</p><h2 id="Markdown的工作原理"><a href="#Markdown的工作原理" class="headerlink" title="Markdown的工作原理"></a>Markdown的工作原理</h2><p>Markdown应用程序都是将Markdown格式的文本转换为HTML，以便可以在Web浏览器中显示。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image.png" alt="Alt text"><br>这是一个四步的过程：</p><ol><li>使用文本编辑器或 Markdown 专用的应用程序创建 Markdown 文件。该文件应带有 .md 或 .markdown 扩展名。</li><li>在 Markdown 应用程序中打开 Markdown 文件。</li><li>使用 Markdown 应用程序将 Markdown 文件转换为 HTML 文档。</li><li>在 web 浏览器中查看 HTML 文件，或使用 Markdown 应用程序将其转换为其他文件格式，例如 PDF。</li></ol><h2 id="Markdown有什么用"><a href="#Markdown有什么用" class="headerlink" title="Markdown有什么用"></a>Markdown有什么用</h2><p>Markdown 是做笔记、为网站创建内容以及生成可打印文档的快速、简便的方法。有如下具体的应用领域：网站、文件资料、笔记、书籍、演示文稿、邮件、文档。</p><h2 id="Markdown方言"><a href="#Markdown方言" class="headerlink" title="Markdown方言"></a>Markdown方言</h2><p>每个Markdown应用程序都实现了稍有不同的Markdown语法。Markdown的这些变体通常被成为<em>flavors（方言）</em></p><h1 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a>二、基本语法</h1><h2 id="Markdown标题语法"><a href="#Markdown标题语法" class="headerlink" title="Markdown标题语法"></a>Markdown标题语法</h2><p>要创建标题，请在单词或短语前面添加井号 (#) 。# 的数量代表了标题的级别。例如，添加三个 # 表示创建一个三级标题(例如：### My Header)。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-1.png" alt="Alt text">  </p><h3 id="可选语法"><a href="#可选语法" class="headerlink" title="可选语法"></a>可选语法</h3><p>还可以在文本下方添加任意数量的 &#x3D;&#x3D; 号来标识一级标题，或者 – 号来标识二级标题。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-2.png" alt="Alt text">  </p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>不同的Markdown应用程序处理 <code>#</code> 和标题之间的空格方式并不一致。为了兼容考虑，请用一个空格在 <code>#</code> 和标题之间进行分隔。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-3.png" alt="Alt text"></p><h2 id="Markdown-段落语法"><a href="#Markdown-段落语法" class="headerlink" title="Markdown 段落语法"></a>Markdown 段落语法</h2><p>要创建段落，请使用空白行将一行或多行文本进行分隔。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-4.png" alt="Alt text"></p><h3 id="段落（paragraph）用法的最佳实践"><a href="#段落（paragraph）用法的最佳实践" class="headerlink" title="段落（paragraph）用法的最佳实践"></a>段落（paragraph）用法的最佳实践</h3><p>不要用空格（spaces）或制表符（tabs）缩进段落。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-5.png" alt="Alt text"></p><h2 id="Markdown换行语法"><a href="#Markdown换行语法" class="headerlink" title="Markdown换行语法"></a>Markdown换行语法</h2><p>在一行的末尾添加两个或多个空格，然后按回车键即可创建一个换行。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-6.png" alt="Alt text"></p><h3 id="换行（Line-Break）用法的最佳实践"><a href="#换行（Line-Break）用法的最佳实践" class="headerlink" title="换行（Line Break）用法的最佳实践"></a>换行（Line Break）用法的最佳实践</h3><p>几乎每个 Markdown 应用程序都支持两个或多个空格进行换行，称为 <strong>结尾空格（trailing whitespace)</strong> 的方式，但这是有争议的，因为很难在编辑器中直接看到空格，并且很多人在每个句子后面都会有意或无意地添加两个空格。由于这个原因，你可能要使用除结尾空格以外的其它方式来换行。幸运的是，几乎每个 Markdown 应用程序都支持另一种换行方式：HTML 的 <code>&lt;br&gt;</code> 标签。</p><p>为了兼容性，请在行尾添加“结尾空格”或 HTML 的 <code>&lt;br&gt;</code> 标签来实现换行。</p><p>还有两种其他方式我并不推荐使用。CommonMark 和其它几种轻量级标记语言支持在行尾添加反斜杠 (\) 的方式实现换行，但是并非所有 Markdown 应用程序都支持此种方式，因此从兼容性的角度来看，不推荐使用。并且至少有两种轻量级标记语言支持无须在行尾添加任何内容，只须键入回车键（return）即可实现换行。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-7.png" alt="Alt text"></p><h2 id="Markdown强调语法"><a href="#Markdown强调语法" class="headerlink" title="Markdown强调语法"></a>Markdown强调语法</h2><p>通过将文本设置为<strong>粗体</strong>或<em>斜体</em>来强调其重要性。</p><h3 id="粗体（Bold）"><a href="#粗体（Bold）" class="headerlink" title="粗体（Bold）"></a>粗体（Bold）</h3><p>要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-8.png" alt="Alt text"></p><h4 id="粗体（Bold）用法最佳实践"><a href="#粗体（Bold）用法最佳实践" class="headerlink" title="粗体（Bold）用法最佳实践"></a>粗体（Bold）用法最佳实践</h4><p>为考虑 Markdown 应用程序的兼容性问题，推荐只使用星号（asterisks）进行加粗强调。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-9.png" alt="Alt text"></p><h3 id="斜体（Italic）"><a href="#斜体（Italic）" class="headerlink" title="斜体（Italic）"></a>斜体（Italic）</h3><p>要用斜体显示文本，请在单词或短语前后添加一个星号（asterisks）或下划线（underscores）。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-10.png" alt="Alt text"></p><h4 id="斜体（Italic）用法的最佳实践"><a href="#斜体（Italic）用法的最佳实践" class="headerlink" title="斜体（Italic）用法的最佳实践"></a>斜体（Italic）用法的最佳实践</h4><p>为考虑 Markdown 应用程序的兼容性问题，推荐只使用星号（asterisks）进行斜体强调。</p><h3 id="粗体（Bold）和斜体（Italic）"><a href="#粗体（Bold）和斜体（Italic）" class="headerlink" title="粗体（Bold）和斜体（Italic）"></a>粗体（Bold）和斜体（Italic）</h3><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-11.png" alt="Alt text"></p><h4 id="粗体（Bold）和斜体（Italic）用法的最佳实践"><a href="#粗体（Bold）和斜体（Italic）用法的最佳实践" class="headerlink" title="粗体（Bold）和斜体（Italic）用法的最佳实践"></a>粗体（Bold）和斜体（Italic）用法的最佳实践</h4><p>为考虑 Markdown 应用程序的兼容性问题，推荐只使用星号进行斜体和斜体强调。</p><h2 id="Markdown-引用语法"><a href="#Markdown-引用语法" class="headerlink" title="Markdown 引用语法"></a>Markdown 引用语法</h2><p>要创建块引用，请在段落前添加一个<code>&gt;</code>符号。</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Dorothy</span> followed her through many <span class="hljs-keyword">of</span> the beautiful rooms <span class="hljs-keyword">in</span> her castle.</span><br></code></pre></td></tr></table></figure><p>渲染效果如下：</p><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p></blockquote><h3 id="多个段落的块引用"><a href="#多个段落的块引用" class="headerlink" title="多个段落的块引用"></a>多个段落的块引用</h3><p>块引用可以包含多个段落。为段落之间的空白行添加一个<code>&gt;</code>符号。</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Dorothy</span> followed her through many <span class="hljs-keyword">of</span> the beautiful rooms <span class="hljs-keyword">in</span> her castle.</span><br><span class="hljs-meta prompt_">&gt;</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">The</span> <span class="hljs-title class_">Witch</span> bade her clean the pots and kettles and sweep the floor and keep the fire fed <span class="hljs-keyword">with</span> wood.</span><br></code></pre></td></tr></table></figure><p>渲染效果如下：</p><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p><p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p></blockquote><h3 id="嵌套块引用"><a href="#嵌套块引用" class="headerlink" title="嵌套块引用"></a>嵌套块引用</h3><p>块引用可以嵌套。在要嵌套的段落前添加一个<code>&gt;&gt;</code>符号。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">&gt; Dorothy followed her through many of the <span class="hljs-keyword">beautiful </span>rooms in her castle.<br>&gt;<br>&gt;&gt; The Witch <span class="hljs-keyword">bade </span>her clean the pots <span class="hljs-keyword">and </span>kettles <span class="hljs-keyword">and </span><span class="hljs-keyword">sweep </span>the floor <span class="hljs-keyword">and </span>keep the fire fed with wood.<br></code></pre></td></tr></table></figure><p>渲染效果如下：</p><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p><blockquote><p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p></blockquote></blockquote><h3 id="带有其它元素的块引用"><a href="#带有其它元素的块引用" class="headerlink" title="带有其它元素的块引用"></a>带有其它元素的块引用</h3><p>块引用可以包含其他 Markdown 格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">#### <span class="hljs-title class_">The</span> quarterly results look great!</span><br><span class="hljs-meta prompt_">&gt;</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">- <span class="hljs-title class_">Revenue</span> was off the chart.</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">- <span class="hljs-title class_">Profits</span> were higher than ever.</span><br><span class="hljs-meta prompt_">&gt;</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"> *<span class="hljs-title class_">Everything</span>* is going according to **plan**.</span><br></code></pre></td></tr></table></figure><p>渲染效果如下：</p><blockquote><h4 id="The-quarterly-results-look-great"><a href="#The-quarterly-results-look-great" class="headerlink" title="The quarterly results look great!"></a>The quarterly results look great!</h4><ul><li>Revenue was off the chart.</li><li>Profits were higher than ever.</li></ul><p> <em>Everything</em> is going according to <strong>plan</strong>.</p></blockquote><h2 id="Markdown-列表语法"><a href="#Markdown-列表语法" class="headerlink" title="Markdown 列表语法"></a>Markdown 列表语法</h2><p>可以将多个条目组织成有序或无序列表。</p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字1起始。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-12.png" alt="Alt text"></p><h4 id="有序列表最佳实践"><a href="#有序列表最佳实践" class="headerlink" title="有序列表最佳实践"></a>有序列表最佳实践</h4><p>一些 Markdown 应用程允许使用圆括号（<code>)</code>）作为分隔符（例：<code>1) First item</code>），但并非所有 Markdown 应用程序都支持它，所以从兼容性的角度考虑推荐只使用英文句点（<code>.</code>）作为分隔符。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-13.png" alt="Alt text"></p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>要创建无序列表，请在每个列表项前面添加破折号（-）、星号（*）或加号（+）。缩进（使用制表符Tab）1个或多个列表项可创建嵌套列表。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-14.png" alt="Alt text"></p><h4 id="无序列表最佳实践"><a href="#无序列表最佳实践" class="headerlink" title="无序列表最佳实践"></a>无序列表最佳实践</h4><p>Markdown 应用程序不支持处理同一列表中存在多个分隔符的情况。为了兼容性的考量，请不要在同意列表中混合使用无序列表分隔符——选中一个并坚持使用它。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-15.png" alt="Alt text"></p><h3 id="在列表中嵌套其他元素"><a href="#在列表中嵌套其他元素" class="headerlink" title="在列表中嵌套其他元素"></a>在列表中嵌套其他元素</h3><p>要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符，如下例所示：</p><h4 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">*   This <span class="hljs-keyword">is</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> <span class="hljs-built_in">list</span> <span class="hljs-built_in">item</span>.<br>*   Here&#x27;s <span class="hljs-keyword">the</span> <span class="hljs-keyword">second</span> <span class="hljs-built_in">list</span> <span class="hljs-built_in">item</span>.<br><br>    I need <span class="hljs-keyword">to</span> add another <span class="hljs-built_in">paragraph</span> <span class="hljs-keyword">below</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">second</span> <span class="hljs-built_in">list</span> <span class="hljs-built_in">item</span>.<br><br>*   And here&#x27;s <span class="hljs-keyword">the</span> <span class="hljs-keyword">third</span> <span class="hljs-built_in">list</span> <span class="hljs-built_in">item</span>.<br></code></pre></td></tr></table></figure><p>渲染效果如下：</p><ul><li><p>This is the first list item.</p></li><li><p>Here’s the second list item.</p><p>I need to add another paragraph below the second list item.</p></li><li><p>And here’s the third list item.</p></li></ul><h4 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">*   This <span class="hljs-keyword">is</span> the first list item.<br>*   Her<span class="hljs-string">e&#x27;s the second list item.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &gt; A blockquote would look great below the second list item.</span><br><span class="hljs-string"></span><br><span class="hljs-string">*   And here&#x27;</span>s the third list item.<br></code></pre></td></tr></table></figure><p>渲染效果如下：</p><ul><li><p>This is the first list item.</p></li><li><p>Here’s the second list item.</p><blockquote><p>A blockquote would look great below the second list item.</p></blockquote></li><li><p>And here’s the third list item.</p></li></ul><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>代码块通常采用四个空格或一个制表符缩进。当它们被放在列表中时，请将它们缩进<em>八个空格或两个制表符</em>。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span>.  Open the <span class="hljs-keyword">file</span>.<br><span class="hljs-number">2</span>.  Find the following code block <span class="hljs-keyword">on</span> <span class="hljs-built_in">line</span> <span class="hljs-number">21</span>:<br><br>        <span class="hljs-symbol">&lt;html&gt;</span><br>          <span class="hljs-symbol">&lt;head&gt;</span><br>            <span class="hljs-symbol">&lt;title&gt;</span>Test&lt;/title&gt;<br>          &lt;/head&gt;<br><br><span class="hljs-number">3</span>.  Update the title <span class="hljs-keyword">to</span> <span class="hljs-keyword">match</span> the name of your website.<br></code></pre></td></tr></table></figure><p>渲染效果如下：</p><ol><li><p>Open the file.</p></li><li><p>Find the following code block on line 21:</p><pre><code class="hljs">&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Test&lt;/title&gt;  &lt;/head&gt;</code></pre></li><li><p>Update the title to match the name of your website.</p></li></ol><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-number">1.</span>  Open the <span class="hljs-keyword">file</span> containing the Linux mascot.<br><span class="hljs-number">2.</span>  Marvel at its beauty.<br><br>    ![Tux, the Linux mascot](MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/<span class="hljs-keyword">image</span><span class="hljs-number">-16.</span>png)<br><br><span class="hljs-number">3.</span>  Close the <span class="hljs-keyword">file</span>.<br></code></pre></td></tr></table></figure><p>渲染效果如下：</p><ol><li><p>Open the file containing the Linux mascot.</p></li><li><p>Marvel at its beauty.</p><p><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-16.png" alt="Tux, the Linux mascot"></p></li><li><p>Close the file.</p></li></ol><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>你可以在有序列表中嵌套无序列表，反之亦然。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1.</span> First <span class="hljs-built_in">item</span><br><span class="hljs-number">2.</span> Second <span class="hljs-built_in">item</span><br><span class="hljs-number">3.</span> Third <span class="hljs-built_in">item</span><br>    - Indented <span class="hljs-built_in">item</span><br>    - Indented <span class="hljs-built_in">item</span><br><span class="hljs-number">4.</span> Fourth <span class="hljs-built_in">item</span><br></code></pre></td></tr></table></figure><p>渲染效果如下：</p><ol><li>First item</li><li>Second item</li><li>Third item<ul><li>Indented item</li><li>Indented item</li></ul></li><li>Fourth item</li></ol><h2 id="Markdown代码语法"><a href="#Markdown代码语法" class="headerlink" title="Markdown代码语法"></a>Markdown代码语法</h2><p>要将单词或短语表示为代码，请将其包裹在反引号（<code>`</code>）中。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-17.png" alt="Alt text"></p><h3 id="转义反引号"><a href="#转义反引号" class="headerlink" title="转义反引号"></a>转义反引号</h3><p>如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号（<code>``</code>）中。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-18.png" alt="Alt text"></p><h3 id="代码块-1"><a href="#代码块-1" class="headerlink" title="代码块"></a>代码块</h3><p>要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Markdown-分隔线语法"><a href="#Markdown-分隔线语法" class="headerlink" title="Markdown 分隔线语法"></a>Markdown 分隔线语法</h2><p>要创建分隔线，请在单独一行上使用三个或多个星号（<code>***</code>）、破折号（<code>---</code>）或下划线（<code>___</code>），并且不能包含其他内容。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">***</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">_________________</span><br></code></pre></td></tr></table></figure><p>以上三个分隔线的渲染效果看起来都一样。</p><h3 id="分隔线（Horizontal-Rule）用法最佳实践"><a href="#分隔线（Horizontal-Rule）用法最佳实践" class="headerlink" title="分隔线（Horizontal Rule）用法最佳实践"></a>分隔线（Horizontal Rule）用法最佳实践</h3><p>为了兼容性，请在分隔线的前后均添加空白行。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-19.png" alt="Alt text"></p><h2 id="Markdown-链接语法"><a href="#Markdown-链接语法" class="headerlink" title="Markdown 链接语法"></a>Markdown 链接语法</h2><p>链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。<br>超链接Markdown语法代码：<code>[超链接显示名](超链接地址 &quot;超链接title&quot;)</code><br>对应的HTML代码：<code>&lt;a href=&quot;超链接地址&quot; title=&quot;超链接title&quot;&gt;超链接显示名&lt;/a&gt;</code><br><code>这是一个链接 [Markdown语法](https://markdown.com.cn)。</code><br>渲染效果如下：<br>这是一个链接 <a href="https://markdown.com.cn/">Markdown语法</a>。</p><h3 id="给链接增加Title"><a href="#给链接增加Title" class="headerlink" title="给链接增加Title"></a>给链接增加Title</h3><p>链接title是当鼠标悬停在链接上时会出现的文字，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。<br><code>这是一个链接 [Markdown语法](https://markdown.com.cn &quot;最好的markdown教程&quot;)。</code><br>渲染效果如下：<br>这是一个链接 <a href="https://markdown.com.cn/" title="最好的markdown教程">Markdown语法</a>。</p><h3 id="网址和Email地址"><a href="#网址和Email地址" class="headerlink" title="网址和Email地址"></a>网址和Email地址</h3><p>使用尖括号可以很方便地把URL或者Email地址变成可点击的链接。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">&lt;https://markdown.<span class="hljs-keyword">com</span>.<span class="hljs-keyword">cn</span>&gt;<br>&lt;<span class="hljs-number">1069667084</span>@qq.<span class="hljs-keyword">com</span>&gt;<br></code></pre></td></tr></table></figure><p>渲染效果如下：<br><a href="https://markdown.com.cn/">https://markdown.com.cn</a><br><a href="mailto:&#x31;&#x30;&#x36;&#x39;&#54;&#x36;&#x37;&#x30;&#56;&#x34;&#64;&#113;&#113;&#x2e;&#99;&#111;&#x6d;">&#x31;&#x30;&#x36;&#x39;&#54;&#x36;&#x37;&#x30;&#56;&#x34;&#64;&#113;&#113;&#x2e;&#99;&#111;&#x6d;</a></p><h3 id="带格式化的链接"><a href="#带格式化的链接" class="headerlink" title="带格式化的链接"></a>带格式化的链接</h3><p><em><strong><a href="https://markdown.com.cn/" title="最好的markdown教程">强调</a></strong></em> 链接，在链接语法前后增加星号。要将链接表示为代码，请在方括号中添加反引号。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">I love supporting the <span class="hljs-strong">**[<span class="hljs-string">EFF</span>](<span class="hljs-link">https://eff.org</span>)**</span>.<br>This is the <span class="hljs-emphasis">*[<span class="hljs-string">Markdown Guide</span>](<span class="hljs-link">https://www.markdownguide.org</span>)*</span>.<br>See the section on [<span class="hljs-string">`code`</span>](<span class="hljs-link">#code</span>).<br></code></pre></td></tr></table></figure><p>渲染效果如下：<br>I love supporting the <strong><a href="https://eff.org/">EFF</a></strong>.<br>This is the <em><a href="https://www.markdownguide.org/">Markdown Guide</a></em>.<br>See the section on <a href="#code"><code>code</code></a>.</p><h3 id="引用类型链接"><a href="#引用类型链接" class="headerlink" title="引用类型链接"></a>引用类型链接</h3><p>引用样式链接是一种特殊的链接，它使URL在Markdown中更易于显示和阅读。参考样式链接分为两部分：与文本保持内联的部分以及存储在文件中其他位置的部分，以使文本易于阅读。</p><h4 id="链接的第一部分格式"><a href="#链接的第一部分格式" class="headerlink" title="链接的第一部分格式"></a>链接的第一部分格式</h4><p>引用类型的链接的第一部分使用两组括号进行格式设置。第一组方括号包围应显示为链接的文本。第二组括号显示了一个标签，该标签用于指向您存储在文档其他位置的链接。</p><p>尽管不是必需的，可以在第一组和第二组括号之间包含一个空格。第二组括号中的标签不区分大小写，可以包含字母，数字，空格或标点符号。</p><p>以下示例格式对于链接的第一部分效果相同：</p><ul><li><code>[hobbit-hole][1]</code></li><li><code>[hobbit-hole] [1]</code></li></ul><h4 id="链接的第二部分格式"><a href="#链接的第二部分格式" class="headerlink" title="链接的第二部分格式"></a>链接的第二部分格式</h4><p>引用类型链接的第二部分使用以下属性设置格式：</p><ol><li>放在括号中的标签，其后紧跟一个冒号和至少一个空格（例如<code>[label]:</code>）。</li><li>链接的URL，可以选择将其括在尖括号中。</li><li>链接的可选标题，可以将其括在双引号，单引号或括号中。</li></ol><p>以下示例格式对于链接的第二部分效果相同：</p><ul><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle</code></li><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle &quot;Hobbit lifestyles&quot;</code></li><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle &#39;Hobbit lifestyles&#39;</code></li><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle (Hobbit lifestyles)</code></li><li><code>[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; &quot;Hobbit lifestyles&quot;</code></li><li><code>[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; &#39;Hobbit lifestyles&#39;</code></li><li><code>[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; (Hobbit lifestyles)</code></li></ul><p>可以将链接的第二部分放在Markdown文档中的任何位置。有些人将它们放在出现的段落之后，有些人则将它们放在文档的末尾（例如尾注和脚注）。</p><h3 id="链接最佳实践"><a href="#链接最佳实践" class="headerlink" title="链接最佳实践"></a>链接最佳实践</h3><p>不同的Markdown应用程序处理URL中间的空格方式不一样。为了兼容性，请尽量使用 <em><strong>%20</strong></em> 代替空格。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20.png" alt="Alt text"></p><h2 id="Markdown-图片语法"><a href="#Markdown-图片语法" class="headerlink" title="Markdown 图片语法"></a>Markdown 图片语法</h2><p>要添加图像，请使用感叹号（<code>!</code>），然后再方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。</p><p>插入图片Markdown语法代码：<code>![图片alt](图片链接 &quot;图片title&quot;)</code>。</p><p>对应的HTML代码：<code>&lt;img src=&quot;图片链接&quot; alt=&quot;图片alt&quot; title=&quot;图片title&quot;&gt;</code></p><p><code>![这是图片](MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-21.png &quot;Magic Gardens&quot;)</code></p><p>渲染效果如下：<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-21.png" alt="这是图片" title="Magic Gardens"></p><h3 id="链接图片"><a href="#链接图片" class="headerlink" title="链接图片"></a>链接图片</h3><p>给图片增加链接，请将图像的Markdown括在方括号中，然后将链接添加在圆括号中。</p><p><code>[![沙漠中的岩石图片](MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-22.png &quot;Shiprock&quot;)](https://markdown.com.cn)</code></p><p>渲染效果如下：</p><p><a href="https://markdown.com.cn/"><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-22.png" alt="沙漠中的岩石图片" title="Shiprock"></a></p><h2 id="Markdown-转义字符语法"><a href="#Markdown-转义字符语法" class="headerlink" title="Markdown 转义字符语法"></a>Markdown 转义字符语法</h2><p>要显示原本用于格式化Markdown文档的字符，请在字符前面添加反斜杠字符<code>\</code>。</p><p><code>\* Without the backslash, this would be a bullet in an unordered list.</code></p><p>渲染效果如下：</p><p>* Without the backslash, this would be a bullet in an unordered list.</p><h3 id="可做转义的字符"><a href="#可做转义的字符" class="headerlink" title="可做转义的字符"></a>可做转义的字符</h3><p>以下列出的字符都可以通过使用反斜杠字符从而达到转义的目的。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-23.png" alt="Alt text"></p><h3 id="特殊字符自动转义"><a href="#特殊字符自动转义" class="headerlink" title="特殊字符自动转义"></a>特殊字符自动转义</h3><p>在HTML文件中，有两个字符需要特殊处理：<code>&lt;</code>和<code>&amp;</code>。<code>&lt;</code>符号用于起始标签，<code>&amp;</code>符号用于标记HTML实体，如果你只是想要使用这些符号，你必须使用实体的形式，像是<code>&amp;lt;</code>和<code>&amp;amp;</code>。</p><p><em>注：lt为less than的缩写，amp为ampersand的缩写</em></p><p><code>&amp;</code> 符号其实很容易让写作网页文件的人感到困扰，如果你要打「AT&amp;T」，你必须要写成「<code>AT&amp;amp;T</code>」，还得转换网址内的<code>&amp;</code>符号，如果你要链接到：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//im</span>ages.google.com/images?num=<span class="hljs-number">30</span>&amp;q=larry+bird<br></code></pre></td></tr></table></figure><p>你必须要把网址转成：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//im</span>ages.google.com/images?num=<span class="hljs-number">30</span>&amp;amp;q=larry+bird<br></code></pre></td></tr></table></figure><p>才能放到链接标签的<code>href</code>属性里。不用说也知道这很容易忘记，这也可能是HTML标准检查所检查到的错误中，数量最多的。</p><p>Markdown允许你直接使用这些符号，它帮你自动转义字符。如果你使用<code>&amp;</code>符号作为HTML实体的一部分，那么它不会被转换，而在其它情况下，它则会被转换成<code>&amp;amp;</code>。所以你如果要在文件中插入一个著作权符号，你可以这样写：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">&amp;copy;</span><br></code></pre></td></tr></table></figure><p>Markdown将不会对这段文字做修改，但是如果你这样写：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">AT<span class="hljs-meta">&amp;T</span><br></code></pre></td></tr></table></figure><p>Markdown就会将它转为：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">AT</span>&amp;amp<span class="hljs-comment">;T</span><br></code></pre></td></tr></table></figure><p>类似的情况也会发生在<code>&lt;</code>符号上，因为Markdown支持行内HTML，如果你使用<code>&lt;</code>符号作为HTML标签的的分隔符，那Markdown也不会对它做任何转换，但是如果你是写：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span>&lt; <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>Markdown将会把它转换为：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span>&amp;lt; <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>需要特别注意的是，在Markdown的块级元素和内联元素中，<code>&lt;</code>和<code>&amp;</code>两个符号都会被自动转换成HTML实体，这项特性让你可以很容易地用Markdown写HTML。（在HTML语法中，你要手动把所有的<code>&lt;</code>和<code>&amp;</code>都转换为HTML实体。）</p><h2 id="Markdown内嵌HTML标签"><a href="#Markdown内嵌HTML标签" class="headerlink" title="Markdown内嵌HTML标签"></a>Markdown内嵌HTML标签</h2><p>对于Markdown涵盖范围之外的标签，都可以直接在文件里面用HTML本身。如需使用HTML，不需要额外标注这是HTML或是Markdown，只需HTML标签添加到Markdown文本中即可。</p><h3 id="行级内联标签"><a href="#行级内联标签" class="headerlink" title="行级内联标签"></a>行级内联标签</h3><p>HTML的行级内联标签如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 不受限制，可以在Markdown的段落、列表或是标题里任意使用。依照个人习惯，甚至可以不用Markdown格式，而采用HTML标签来格式化。例如：如果比较喜欢 HTML 的 <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 标签，可以直接使用这些标签，而不用Markdown提供的链接或是图片语法。当你需要更改元素的属性时（例如为文本指定颜色或更改图像的宽度），使用 HTML 标签更方便些。</p><p>HTML 行级內联标签和区块标签不同，在內联标签的范围内， Markdown的语法是可以解析的。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">This **<span class="hljs-built_in">word</span>** <span class="hljs-keyword">is</span> bold. This &lt;em&gt;<span class="hljs-built_in">word</span>&lt;/em&gt; <span class="hljs-keyword">is</span> italic.<br></code></pre></td></tr></table></figure><p>渲染效果如下：</p><p>This <strong>word</strong> is bold. This <em>word</em> is italic.</p><h3 id="区块标签"><a href="#区块标签" class="headerlink" title="区块标签"></a>区块标签</h3><p>区块元素──比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在前后加上空行，以便于内容区分。而且这些元素的开始与结尾标签，不可以用tab或是空白来缩进。Markdown会自动识别这区块元素，避免在区块标签前后加上没有必要的 <code>&lt;p&gt;</code> 标签。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xquery">This <span class="hljs-literal">is</span> a regular paragraph.<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><br><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">        </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Foo<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><br>This <span class="hljs-literal">is</span> another regular paragraph.<br></code></pre></td></tr></table></figure><p>请注意，Markdown语法在HTML区块标签中将不会被进行处理。例如，你无法在HTML区块中使用Markdown形式的<code>*强调*</code>。</p><h3 id="HTML用法最佳实践"><a href="#HTML用法最佳实践" class="headerlink" title="HTML用法最佳实践"></a>HTML用法最佳实践</h3><p>出于安全原因，并非所有Markdown应用程序都支持在Markdown文档中添加HTML。如有疑问，请查看相应Markdown应用程序手册。某些应用程序只支持HTML标签的子集。</p><p>对于HTML的块级元素 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> ，请在其前后使用空行（blank lines）与其它内容进行分隔。尽量不要使用制表符（tabs）或空格（spaces）对HTML标签做缩进，否则将影响格式。</p><p>在HTML块级标签内不能使用Markdown语法。例如 <code>&lt;p&gt;italic and **bold**&lt;/p&gt;</code> 将不起作用。</p><h1 id="三、扩展语法"><a href="#三、扩展语法" class="headerlink" title="三、扩展语法"></a>三、扩展语法</h1><h2 id="Markdown扩展语法入门"><a href="#Markdown扩展语法入门" class="headerlink" title="Markdown扩展语法入门"></a>Markdown扩展语法入门</h2><p>John Gruber的原始设计文档中概述的基本语法主要是为了应付大多数情况下的日常所需元素，但对于某些人来说还不够，这就是扩展语法的用武之地。</p><p>一些个人和组织开始通过添加其他元素（例如表，代码块，语法突出显示，URL自动链接和脚注）来扩展基本语法。可以通过使用基于基本Markdown语法的轻量级标记语言，或通过向兼容的Markdown处理器添加扩展来启用这些元素。</p><h2 id="Markdown扩展语法可用性"><a href="#Markdown扩展语法可用性" class="headerlink" title="Markdown扩展语法可用性"></a>Markdown扩展语法可用性</h2><p>并非所有Markdown应用程序都支持扩展语法元素。您需要检查您的应用程序所使用的轻量级标记语言是否支持您要使用的扩展语法元素。如果没有，那么仍然有可能在Markdown处理器中启用扩展。</p><h3 id="轻量标记语言"><a href="#轻量标记语言" class="headerlink" title="轻量标记语言"></a>轻量标记语言</h3><p>有几种轻量级标记语言是Markdown的超集（反过来说Markdown是它们的子集）。它们包含Gruber的基本语法，并通过添加其他元素（例如表，代码块，语法突出显示，URL自动链接和脚注）在此基础上构建。许多最受欢迎的Markdown应用程序使用以下轻量级标记语言之一：</p><ul><li><a href="https://commonmark.org/">CommonMark</a></li><li><a href="https://github.github.com/gfm/">GitHub Flavored Markdown (GFM)</a></li><li><a href="https://michelf.ca/projects/php-markdown/extra/">Markdown Extra</a></li><li><a href="https://fletcherpenney.net/multimarkdown/">MultiMarkdown</a></li><li><a href="https://rmarkdown.rstudio.com/">R Markdown</a></li></ul><h3 id="Markdown-处理器"><a href="#Markdown-处理器" class="headerlink" title="Markdown 处理器"></a>Markdown 处理器</h3><p>有许多<a href="https://github.com/markdown/markdown.github.com/wiki/Implementations">Markdown处理器</a>可用。它们中的许多允许您添加启用扩展语法元素的扩展。查看您所使用处理器的文档以获取更多信息。</p><h2 id="Markdown表格"><a href="#Markdown表格" class="headerlink" title="Markdown表格"></a>Markdown表格</h2><p>要添加表，请使用三个或多个连字符（<code>---</code>）创建每列的标题，并使用管道（<code>|</code>）分隔每列。您可以选择在表的任一端添加管道。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> Syntax      </span>|<span class="hljs-string"> Description </span>|<br>|<span class="hljs-string"> ----------- </span>|<span class="hljs-string"> ----------- </span>|<br>|<span class="hljs-string"> Header      </span>|<span class="hljs-string"> Title       </span>|<br>|<span class="hljs-string"> Paragraph   </span>|<span class="hljs-string"> Text        </span>|<br></code></pre></td></tr></table></figure><p>呈现出的输出如下所示：</p><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td>Title</td></tr><tr><td>Paragraph</td><td>Text</td></tr><tr><td>单元格的宽度可依变化，如下所示。呈现的输出将看起来相同。</td><td></td></tr></tbody></table><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> Syntax </span>|<span class="hljs-string"> Description </span>|<br>|<span class="hljs-string"> --- </span>|<span class="hljs-string"> ----------- </span>|<br>|<span class="hljs-string"> Header </span>|<span class="hljs-string"> Title </span>|<br>|<span class="hljs-string"> Paragraph </span>|<span class="hljs-string"> Text </span>|<br></code></pre></td></tr></table></figure><p>**Tip:**使用连字符和管道创建表可能很麻烦。为了加快该进程，请尝试使用<a href="https://www.tablesgenerator.com/markdown_tables">Markdown Tables Generator</a>。使用图形界面构建表，然后将生成的Markdown格式的文本复制到文件中。</p><h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p>您可以通过在标题行中的连字符左侧，右侧或两侧添加冒号（<code>:</code>），将列中的文本对齐到左侧，右侧或中心。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> Syntax      </span>|<span class="hljs-string"> Description </span>|<span class="hljs-string"> Test Text     </span>|<br>|<span class="hljs-string"> :---        </span>|<span class="hljs-string">    :----:   </span>|<span class="hljs-string">          ---: </span>|<br>|<span class="hljs-string"> Header      </span>|<span class="hljs-string"> Title       </span>|<span class="hljs-string"> Here&#x27;s this   </span>|<br>|<span class="hljs-string"> Paragraph   </span>|<span class="hljs-string"> Text        </span>|<span class="hljs-string"> And more      </span>|<br></code></pre></td></tr></table></figure><p>呈现的输出如下所示：</p><table><thead><tr><th align="left">Syntax</th><th align="center">Description</th><th align="right">Test Text</th></tr></thead><tbody><tr><td align="left">Header</td><td align="center">Title</td><td align="right">Here’s this</td></tr><tr><td align="left">Paragraph</td><td align="center">Text</td><td align="right">And more</td></tr></tbody></table><h3 id="格式化表格中的文字"><a href="#格式化表格中的文字" class="headerlink" title="格式化表格中的文字"></a>格式化表格中的文字</h3><p>您可以在表格中设置文本格式。例如，您可以添加链接，代码（仅反引号（<code>`</code>）中的单词或短语，而不是代码块）和强调。</p><p>您不能添加标题，块引用，列表，水平规则，图像或HTML标签。</p><h3 id="在表中转义管道字符"><a href="#在表中转义管道字符" class="headerlink" title="在表中转义管道字符"></a>在表中转义管道字符</h3><p>您可以使用表格的HTML字符代码（<code>&amp;#124;</code>）在表中显示竖线（<code>|</code>）字符。</p><h2 id="Markdown围栏代码块"><a href="#Markdown围栏代码块" class="headerlink" title="Markdown围栏代码块"></a>Markdown围栏代码块</h2><p>Markdown基本语法允许您通过将行缩进四个空格或一个制表符来创建代码块。如果发现不方便，请尝试使用受保护的代码块。根据Markdown处理器或编辑器的不同，您将在代码块之前和之后的行上使用三个反引号（<code>```</code>）或三个波浪号（<code>~~~</code>）。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">```<br>&#123;<br>  <span class="hljs-string">&quot;firstName&quot;</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-string">&quot;lastName&quot;</span>: <span class="hljs-string">&quot;Smith&quot;</span>,<br>  <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">25</span><br>&#125;<br>```<br></code></pre></td></tr></table></figure><p>呈现的输出如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Smith&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">25</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>Tip:</strong> 要在代码块中显示反引号？使用<code>````</code>代替<code>```</code>括住代码区域即可。</p><h3 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h3><p>许多Markdown处理器都支持受围栏代码块的语法突出显示。使用此功能，您可以为编写代码的任何语言加颜色突出显示。要添加语法突出显示，请在受防护的代码块之前的反引号旁指定一种语言。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">```json<br>&#123;<br>  <span class="hljs-string">&quot;firstName&quot;</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-string">&quot;lastName&quot;</span>: <span class="hljs-string">&quot;Smith&quot;</span>,<br>  <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">25</span><br>&#125;<br>```<br></code></pre></td></tr></table></figure><p>呈现的输出如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Smith&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">25</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="Markdown脚注"><a href="#Markdown脚注" class="headerlink" title="Markdown脚注"></a>Markdown脚注</h2><p>脚注使您可以添加注释和参考，而不会使文档正文混乱。当您创建脚注时，带有脚注的上标数字会出现在您添加脚注参考的位置。读者可以单击链接以跳转至页面底部的脚注内容。</p><p>要创建脚注参考，请在方括号（<code>&lt;sup id=&quot;fnref:1&quot; class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--rounded&quot; aria-label=&quot;My footnote.</code>）您不必在文档末尾添加脚注。您可以将它们放在除列表，块引号和表的其他元素之外的任何位置。</p><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre><pre><code class="hljs pgsql">Her<span class="hljs-string">e&#x27;s a simple footnote,[^1] and here&#x27;</span>s a longer one.[^bignote]<br><br>[^<span class="hljs-number">1</span>]: This <span class="hljs-keyword">is</span> the first footnote.<br><br>[^bignote]: Her<span class="hljs-string">e&#x27;s one with multiple paragraphs and code.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Indent paragraphs to include them in the footnote.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    `&#123; my code &#125;`</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Add as many paragraphs as you like.</span><br></code></pre><p>呈现的输出如下所示：<br>Here’s a simple footnote,”&gt;[1]&#96;）内添加插入符号和标识符。标识符可以是数字或单词，但不能包含空格或制表符。标识符仅将脚注参考与脚注本身相关联。在输出中，脚注按顺序编号。</p><p>在括号内使用另一个插入符号和数字添加脚注，并用冒号和文本（<code>&lt;sup id=&quot;fnref:1&quot; class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--rounded&quot; aria-label=&quot;My footnote.</code>）您不必在文档末尾添加脚注。您可以将它们放在除列表，块引号和表的其他元素之外的任何位置。</p><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre><pre><code class="hljs applescript">[^<span class="hljs-number">1</span>]: This <span class="hljs-keyword">is</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> footnote.<br><br>[^bignote]: Here&#x27;s one <span class="hljs-keyword">with</span> multiple <span class="hljs-built_in">paragraphs</span> <span class="hljs-keyword">and</span> code.<br><br>    Indent <span class="hljs-built_in">paragraphs</span> <span class="hljs-keyword">to</span> include them <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> footnote.（段落缩进以使它们包含在脚注中）<br><br>    `&#123; <span class="hljs-keyword">my</span> code &#125;`<br><br>    Add <span class="hljs-keyword">as</span> many <span class="hljs-built_in">paragraphs</span> <span class="hljs-keyword">as</span> you like.<br></code></pre><p>呈现的输出如下所示：<br>Here’s a simple footnote,”&gt;[1] and here’s a longer one.[^bignote]</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">### My Great Heading &#123;#custom-id&#125;<br></code></pre></td></tr></table></figure><h2 id="Markdown标题编号"><a href="#Markdown标题编号" class="headerlink" title="Markdown标题编号"></a>Markdown标题编号</h2><p>许多Markdown处理器支持标题的自定义ID —— 一些Markdown处理器会自动添加它们。添加自定义ID允许您直接连接到标题并使用CSS对其进行修改。要添加自定义标题ID，请在与标题相同的行上用大括号括起该自定义ID。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;custom-id&quot;</span>&gt;</span>My Great Heading<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br></code></pre></td></tr></table></figure><p>HTML看起来像这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">First Term<br>: This is <span class="hljs-keyword">the</span> definition <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> term.<br><br>Second Term<br>: This is <span class="hljs-literal">one</span> definition <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">second</span> term.<br>: This is another definition <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">second</span> term.<br></code></pre></td></tr></table></figure><h3 id="连接到标题ID（-headid）"><a href="#连接到标题ID（-headid）" class="headerlink" title="连接到标题ID（#headid）"></a>连接到标题ID（#headid）</h3><p>通过创建带有数字符号（<code>#</code>）和自定义标题ID的标准链接，可以链接到文件中具有自定义ID的标题。</p><table><thead><tr><th>Markdown</th><th>HTML</th><th>预览效果</th></tr></thead><tbody><tr><td><code>[Heading IDs](#heading-ids)</code></td><td><code>&lt;a href=&quot;#heading-ids&quot;&gt;Heading IDs&lt;/a&gt;</code></td><td><a href="#heading-ids">Heading IDs</a></td></tr></tbody></table><p>其他网站可以通过将自定义标题ID添加到网页的完整URL（例如<code>[Heading IDs](https://markdown.com.cn/extended-syntax/heading-ids.html#headid)</code>）来链接到标题。</p><h2 id="Markdown定义列表"><a href="#Markdown定义列表" class="headerlink" title="Markdown定义列表"></a>Markdown定义列表</h2><p>一些Markdown处理器允许您创建术语及其对应定义的<em>定义列表</em>。要创建定义列表，请在第一行上键入术语。在下一行，键入一个冒号，后跟一个空格和定义。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>First Term<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>This is the definition of the first term.<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Second Term<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>This is one definition of the second term. <span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>This is another definition of the second term.<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><p>HTML看起来像这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml">~~世界是平坦的。~~ 我们现在知道世界是圆的。<br></code></pre></td></tr></table></figure><dl><dt>呈现的输出如下所示：<br>First Term<br>: This is the definition of the first term.<br>Second Term<br>: This is one definition of the second term.</dt><dd>This is another definition of the second term.</dd></dl><h2 id="Markdown删除线"><a href="#Markdown删除线" class="headerlink" title="Markdown删除线"></a>Markdown删除线</h2><p>您可以通过在单词中心放置一条水平线来删除单词。结果看起来<del>像这样</del>。此功能使您可以指示某些单词是一个错误，要从文档中删除。若要删除单词，请在单词前后使用两个波浪号<code>~~</code>。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>[x] Write the press release<br><span class="hljs-bullet">- </span>[ ] Update the website<br><span class="hljs-bullet">- </span>[ ] Contact the media<br></code></pre></td></tr></table></figure><p>呈现的输出如下所示：<br><del>世界是平坦的。</del> 我们现在知道世界是圆的。</p><h2 id="Markdown任务列表语法"><a href="#Markdown任务列表语法" class="headerlink" title="Markdown任务列表语法"></a>Markdown任务列表语法</h2><p>任务列表使您可以创建带有复选框的项目列表。在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。要创建任务列表，请在任务列表之前添加破折号<code>-</code>和方括号<code>[]</code>，并在<code>[]</code>前面加上空格。要选择一个复选框，请在方括号<code>[x]</code>之间添加x。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">去露营了！ <span class="hljs-symbol">:tent</span>: 很快回来。<br><br>真好笑！ <span class="hljs-symbol">:joy</span><span class="hljs-symbol">:</span><br></code></pre></td></tr></table></figure><p>呈现的输出如下所示：</p><ul><li><input checked disabled type="checkbox"> Write the press release</li><li><input disabled type="checkbox"> Update the website</li><li><input disabled type="checkbox"> Contact the media</li></ul><h2 id="Markdown使用Emoji表情"><a href="#Markdown使用Emoji表情" class="headerlink" title="Markdown使用Emoji表情"></a>Markdown使用Emoji表情</h2><p>有两种方法可以将表情符号添加到Markdown文件中：将表情符号复制并粘贴到Markdown格式的文本中，或者键入emoji shortcodes。</p><h3 id="复制和粘贴表情符号"><a href="#复制和粘贴表情符号" class="headerlink" title="复制和粘贴表情符号"></a>复制和粘贴表情符号</h3><p>在大多数情况下，您可以简单地从<a href="https://emojipedia.org/">Emojipedia</a>等来源复制表情符号并将其粘贴到文档中。许多Markdown应用程序会自动以Markdown格式的文本显示表情符号。从Markdown应用程序到处的HTML和PDF文件应显示表情符号。</p><p><strong>Tip:</strong> 如果您使用的时静态网站生成器，请确保HTML页面编码为UTF-8。</p><h3 id="使用表情符号简码"><a href="#使用表情符号简码" class="headerlink" title="使用表情符号简码"></a>使用表情符号简码</h3><p>一些Markdown应用程序允许您通过键入表情符号短代码来插入表情符号。这些以冒号开头和结尾，并包含表情符号的名称。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>www.example.com<br></code></pre></td></tr></table></figure><p>呈现的输出如下所示：</p><p>去露营了！ :tent: 很快回来。</p><p>真好笑！ :joy:</p><p><strong>Note:</strong> 注意：您可以使用此表情符号简码列表，但请记住，表情符号简码因应用程序而异。有关更多信息，请参阅Markdown应用程序的文档。</p><h2 id="自动网址链接"><a href="#自动网址链接" class="headerlink" title="自动网址链接"></a>自动网址链接</h2><p>许多Markdown处理器会自动将URL转换为链接。这意味着如果您输入<code>http://www.example.com</code>，即使您未使用方括号，您的Markdown处理器也会自动将其转换为链接。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">`http:<span class="hljs-regexp">//</span>www.example.com`<br></code></pre></td></tr></table></figure><p>呈现的输出如下所示：</p><p><a href="http://www.example.com/">http://www.example.com</a></p><h3 id="禁用自动URL链接"><a href="#禁用自动URL链接" class="headerlink" title="禁用自动URL链接"></a>禁用自动URL链接</h3><p>如果您不希望自动URL链接，则可以通过将URL表示为带反引号的代码来删除该链接。</p><figure class="highlight awk"><table><tr><td class="gutter">undefined</td><td class="code">undefined</td></tr></table></figure><p>呈现的输出如下所示：</p><p><code>http://www.example.com</code><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>My footnote.&#96;）您不必在文档末尾添加脚注。您可以将它们放在除列表，块引号和表的其他元素之外的任何位置。<br><figure class="highlight pgsql"><table><tr><td class="gutter">undefined</td><td class="code">undefined</td></tr></table></figure><br>呈现的输出如下所示：<br>Here’s a simple footnote,<br><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></p>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows下部署Hexo博客过程</title>
    <link href="/2023/09/20/Windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/09/20/Windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本过程完全按照CodeSheep的视频（ <a href="https://www.bilibili.com/video/BV1Yb411a7ty">https://www.bilibili.com/video/BV1Yb411a7ty</a> ）操作，区别是在Windows环境下而非MacOS下部署。在此描述出所有步骤，以及踩过的一些坑。</p><h1 id="一、前置环境搭建"><a href="#一、前置环境搭建" class="headerlink" title="一、前置环境搭建"></a>一、前置环境搭建</h1><h2 id="Node-JS、npm安装"><a href="#Node-JS、npm安装" class="headerlink" title="Node.JS、npm安装"></a>Node.JS、npm安装</h2><p>进入官网 <a href="https://nodejs.org/">https://nodejs.org</a> 选择LTS(Long Term Support)版本执行全默认安装即可。</p><p>使用PowerShell（管理员模式）输入命令：<br><code>node -v</code><br>验证安装是否成功</p><h2 id="cnpm安装"><a href="#cnpm安装" class="headerlink" title="cnpm安装"></a>cnpm安装</h2><p><code>npm install -g cnpm --registry=http://registry.npm.taobao.org#安装淘宝源的 cnpm 管理器</code></p><h2 id="两个坑"><a href="#两个坑" class="headerlink" title="两个坑"></a>两个坑</h2><ul><li><p>安装cnpm提示”x packages are looking for funding.”<br>可选择忽略或install或使用<br><code>npm install --no-fund  -g cnpm --registry=http://registry.npm.taobao.org</code><br>的方式跳过fund。<sup>[1]</sup></p></li><li><p>输入 cnpm -v 后提示”无法加载文件 C:\Users*****\AppData\Roaming\npm\cnpm.ps1，因为在此系统上禁止运行脚本”<br>请使用命令<br><code>set-ExecutionPolicy RemoteSigned</code><br>允许在系统上运行脚本。<sup>[2]</sup></p></li></ul><hr><h1 id="二、Hexo框架安装与配置"><a href="#二、Hexo框架安装与配置" class="headerlink" title="二、Hexo框架安装与配置"></a>二、Hexo框架安装与配置</h1><h2 id="Hexo框架安装"><a href="#Hexo框架安装" class="headerlink" title="Hexo框架安装"></a>Hexo框架安装</h2><p><code>cnpm install -g hexo-cli</code></p><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><ul><li><p>安装过程提示需要git<br><a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a> 官方提供两种方式安装，这里使用PowerShell中的命令行安装，命令如下：<br><code>winget install --id Git.Git -e --source winget</code><br>重启PowerShell后即安装成功</p></li><li><p>Git报错： Failed to connect to github.com port 443 解决方案<br>由于我手里有魔法，故根据CSDN上的教程<sup>[3]</sup>修改sock5和http代理即可</p></li></ul><h2 id="Hexo的配置"><a href="#Hexo的配置" class="headerlink" title="Hexo的配置"></a>Hexo的配置</h2><ul><li><p>选择一个目标位置创建Blog文件夹（这里选择C:\Blog）<br><code>mkdir blog</code><br><code>cd blog</code></p></li><li><p>初始化<br><code>hexo init #win环境下无需sudo，管理员模式启动即可</code></p></li></ul><hr><h1 id="三、常用命令"><a href="#三、常用命令" class="headerlink" title="三、常用命令"></a>三、常用命令</h1><ul><li><p>本地预览<br><code>hexo server #或 hexo s 启动预览</code><br>进入 <a href="http://localhost:4000/">http://localhost:4000/</a> 本地访问地址</p></li><li><p><code>hexo new &quot;我的第一篇文章&quot; #或 hexo n 创建新的文章 </code></p></li><li><p><code>hexo clean #或 hexo c 清理</code></p></li><li><p><code>hexo generate #或 hexo g 生成</code></p></li><li><p><code>hexo deploy #或 hexo d部署到远端</code></p></li></ul><hr><h1 id="四、部署到远端（以Github为例）"><a href="#四、部署到远端（以Github为例）" class="headerlink" title="四、部署到远端（以Github为例）"></a>四、部署到远端（以Github为例）</h1><h2 id="登录Github创建一个新的仓库"><a href="#登录Github创建一个新的仓库" class="headerlink" title="登录Github创建一个新的仓库"></a>登录Github创建一个新的仓库</h2><p>坑：<br>· 必须以 用户名.github.io的形式命名仓库<br>· 必须是public库而非private库，否则可能会遇到404问题</p><h2 id="在Blog目录下安装git部署插件"><a href="#在Blog目录下安装git部署插件" class="headerlink" title="在Blog目录下安装git部署插件"></a>在Blog目录下安装git部署插件</h2><p><code>cnpm install --save hexo-deployer-git #注意必须是Blog目录下，否则请删除Blog重来</code></p><h2 id="配置Blog目录下的-config-yml-文件"><a href="#配置Blog目录下的-config-yml-文件" class="headerlink" title="配置Blog目录下的 _config.yml 文件"></a>配置Blog目录下的 _config.yml 文件</h2><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts">   \<span class="hljs-meta"># Deployment  </span><br>\<span class="hljs-meta">## Docs: https:<span class="hljs-comment">//hexo.io/docs/deployment.html  </span></span><br><span class="hljs-symbol">deploy:</span>  <br><span class="hljs-symbol"> type:</span> git  <br><span class="hljs-symbol">repo:</span> https:<span class="hljs-comment">//github.com/YourGithubName/YourGithubName.github.io.git  </span><br><span class="hljs-symbol"> branch:</span> master  <br></code></pre></td></tr></table></figure><h2 id="部署到远端"><a href="#部署到远端" class="headerlink" title="部署到远端"></a>部署到远端</h2><p><code>hexo deploy #或hexo d</code></p><h2 id="访问博客"><a href="#访问博客" class="headerlink" title="访问博客"></a>访问博客</h2><p><a href="https://yourgithubname.github.io.git即你的博客地址/">https://YourGithubName.github.io.git即你的博客地址</a></p><hr><h1 id="五、更换博客皮肤（非必须，以Yilia为例）"><a href="#五、更换博客皮肤（非必须，以Yilia为例）" class="headerlink" title="五、更换博客皮肤（非必须，以Yilia为例）"></a>五、更换博客皮肤（非必须，以Yilia为例）</h1><ul><li><code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia  #下载yilia主题到本地</code></li></ul><h2 id="修改-config-yml配置文件"><a href="#修改-config-yml配置文件" class="headerlink" title="修改_config.yml配置文件"></a>修改_config.yml配置文件</h2><ul><li>theme: landscape 改为 theme: yilia</li></ul><h2 id="清理、生成、部署、查看"><a href="#清理、生成、部署、查看" class="headerlink" title="清理、生成、部署、查看"></a>清理、生成、部署、查看</h2><ul><li><code>hexo c #清理</code>  </li><li><code>hexo g #生成</code> </li><li><code>hexo d #部署</code> </li><li>访问 <a href="https://yourgithubname.github.io.git/">https://YourGithubName.github.io.git</a>  #查看</li></ul><hr><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ul><li>博文的具体内容在 &#x2F;Blog&#x2F;source&#x2F;_posts&#x2F;我的第一篇文章.md中修改</li><li>推荐使用开源软件 VSCode + 插件MarkDown All in One查看修改.md文件</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] <a href="https://www.likecs.com/ask-545634.html">https://www.likecs.com/ask-545634.html</a><br>[2] <a href="https://zhuanlan.zhihu.com/p/617284262">https://zhuanlan.zhihu.com/p/617284262</a><br>[3] <a href="https://blog.csdn.net/zpf1813763637/article/details/128340109">https://blog.csdn.net/zpf1813763637/article/details/128340109</a>  </p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
