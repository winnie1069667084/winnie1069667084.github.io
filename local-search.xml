<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Sunshine + Moonlight 实现低延迟远程串流</title>
    <link href="/2023/11/28/Sunshine-Moonlight-%E5%AE%9E%E7%8E%B0%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/"/>
    <url>/2023/11/28/Sunshine-Moonlight-%E5%AE%9E%E7%8E%B0%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>这两天沉迷于搞远程串流，市面上有很多远程串流软件，我用过的就有如：Windows远程桌面连接、向日葵、Pasec等。最终还是选择了Sunshine+ Moonlight的方案，在这里写一篇博客记录下整个过程。</p><h1 id="网络篇">网络篇</h1><h2 id="公网ipv4申请可选">公网IPv4申请（可选）</h2><p>由于Moonlight支持公网IPv6访问，因此拥有IPv6地址的用户可以跳过本步骤。</p><p>对各运营商来说IPv4地址是紧缺资源，所以申请各运营商的IPv4地址的难易程度也不尽相同。</p><p>本人目前在郑州市区使用的是联通的宽带，申请过程非常简单。只需要拨打联通宽带“98480”电话，告诉客服你需要申请公网IP即可，等客服确认你的身份，并且询问过你开公网IP的用途（家用远程设备访问、游戏服务器搭建等）后当时就能开通。</p><h2 id="光猫改桥接模式">光猫改桥接模式</h2><p>但这时虽然拿到了公网IP还不能直接使用，宽带运营商在装家用带宽时会将光猫默认设置为路由模式，此时的光猫除了进行一般的光电信号转换外，还有路由器的功能。</p><p>而我们的终端设备需要连接家里的路由再过光猫才能与互联网沟通，此时路由器与光猫组成双NAT，如果我们需要远程访问家庭网络中的设备，则需要在两个路由器上都进行端口映射，十分繁琐。</p><p>所以这时我们要把光猫由路由模式改为桥接模式，砍掉它的路由功能只保留光电信号转换功能。</p><p>这里就以我的设备为例，讲解下光猫的桥接模式修改。</p><p>首先找到家里的光猫，背面会提供以下信息，需要记住后面会用到：</p><ol type="1"><li>Web页面地址</li><li>默认用户名</li><li>默认用户密码</li></ol><figure><img src="/2023/11/28/Sunshine-Moonlight-%E5%AE%9E%E7%8E%B0%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/35fc133dc92f4b0e81c855997af14aeb.jpeg" alt="光猫背面信息"><figcaption aria-hidden="true">光猫背面信息</figcaption></figure><p>接下来在浏览器中输入Web页面地址<strong>192.168.1.1</strong>进入光猫的管理界面。</p><figure><img src="/2023/11/28/Sunshine-Moonlight-%E5%AE%9E%E7%8E%B0%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/image.png" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><p>输入默认用户名，默认密码并登录。</p><figure><img src="/2023/11/28/Sunshine-Moonlight-%E5%AE%9E%E7%8E%B0%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/image-1.png" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><p>在 “网络 - 宽带配置” 选项卡中将对应的连接模式由 “PPPoE” 改为“Bridge”，并确认，此时设备会处于断网状态。</p><p>早些年各运营商会把改桥接功能藏在超级用户里（防止客户乱改导致需要工程师频繁上门维护），现在需要改桥接的用户多了联通就把这个功能放在默认普通用户里了，可以不用再费尽心思的找超级管理账户的账号密码了。如果你的光猫仍然需要超级账户才能改桥接，请自行搜索或询问运营商取得超级管理账户和密码。</p><figure><img src="/2023/11/28/Sunshine-Moonlight-%E5%AE%9E%E7%8E%B0%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/image-2.png" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><p>这里可以顺便来到 “网络 - WLAN配置” 选项卡中，将所有SSID的 “SSID使能”关闭，以关闭光猫的无线功能，减少对路由器的信号干扰。</p><p>到这一步光猫的设置就完成了，现在转到路由器的设置，不同路由器有不同的设置方式，但殊途同归，这里拿我用的TP-LINK路由举例说明。</p><figure><img src="/2023/11/28/Sunshine-Moonlight-%E5%AE%9E%E7%8E%B0%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/image-3.png" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><p>登录路由器的管理界面后将 “上网方式” 由 “自动获得IP地址” 改为“宽带拨号上网（PPPoE）”。然后输入宽带账号和宽带密码（一般写在光猫上或打运营商电话取得），这时拨号上网的功能就转移到路由器上了，待路由获取到IP，设备就将恢复联网。</p><p>此时路由获取的IP地址即为公网IP，可以通过百度搜索 “IP”来对照路由IP是否相同来判断是否真的获取到了公网IP。</p><figure><img src="/2023/11/28/Sunshine-Moonlight-%E5%AE%9E%E7%8E%B0%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/image-4.png" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><p>需要注意的是，设置完路由器拨号后，光猫的Web页面将不能通过192.168.1.1访问，如需管理光猫设备需要将路由改回“自动获得IP” 地址再进行操作。</p><h2 id="动态域名解析ddns">动态域名解析（DDNS）</h2><p>家庭用户一般从运营商申请到的公网IPv4都是动态公网IP，根据不同运营商的服务策略申请到的IP会在数小时到数月内发生更改，如果不进行动态域名解析（DDNS）那么我们需要频繁的查看路由器当前的IP地址是否被更改，十分的麻烦。</p><p>路由器或网络上有很多提供免费DDNS的服务商（TPLINK、花生壳等），通过注册账号即可申请到免费的域名来解析我们获得的动态公网IP。</p><figure><img src="/2023/11/28/Sunshine-Moonlight-%E5%AE%9E%E7%8E%B0%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/image-5.png" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><p>依然以TP-LINK路由器为例，其内置DDNS应用，我们可以很简单的申请到一个<strong>xxx.tpddns.cn</strong>地址用来解析我们的动态公网IP，之后Moonlight中需要我们填入目标IP时直接通过输入该地址解析即可。</p><h2 id="ip---mac绑定">IP - MAC绑定</h2><p>在上一步中我们实现了动态公网IP的DDNS（相当于固定了路由的IP地址），但同一路由器中可能连接有其他不同的设备，且这些设备的局域网内IP地址也时常变动，如果我们想精准的访问内网中的设备就需要将内网IP与设备的MAC地址绑定。</p><p>MAC地址也叫物理地址、硬件地址，由网络设备制造商生产时烧录在网卡的相关芯片当中，MAC地址通常表示为12个16进制数，其地址是全球唯一的，可以当作网络硬件的身份证。</p><figure><img src="/2023/11/28/Sunshine-Moonlight-%E5%AE%9E%E7%8E%B0%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/image-6.png" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><p>可以看到我的局域网内有很多设备，我只想通过外网访问我的台式机，这里我添加了一个绑定设置，使得路由器只给某一确定的MAC地址（台式机）绑定固定的内网IP地址<strong>192.168.0.100</strong>，之后无论内网设备如何变动我的台式机都只会拥有唯一的内网IP192.168.0.100。</p><h2 id="dmz主机或端口映射虚拟服务器">DMZ主机或端口映射（虚拟服务器）</h2><p>之前两步，我们“固定”了公网和内网设备IP地址，唯一确定了我们想访问设备的地址，但现在还不能外网直接访问目标设备，因为实际上拥有公网IP的是路由器而非目标设备，所以这一步我们要做的就是将设备的端口一一映射到路由器中，达成我们访问路由器某一端口就能直接访问目标设备端口的目的。完成这一目标我们有两个方案可选：<strong>DMZ主机</strong>和<strong>端口映射（虚拟服务器）</strong>。</p><h3 id="dmz主机">DMZ主机</h3><p>所谓DMZ主机，即完全开放我们内网中的某一设备给公网，适用于内网中只有单设备需要被外部访问的情况，我目前只需要外网能够访问我的台式机即可，所以选择了这种方案。</p><figure><img src="/2023/11/28/Sunshine-Moonlight-%E5%AE%9E%E7%8E%B0%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/image-7.png" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><p>设置DMZ主机的方式也十分简单，只需要设置目标设备的内网IP地址即可，这里我们填上<strong>192.168.0.100</strong>就大功告成了。</p><h3 id="端口映射虚拟服务器">端口映射（虚拟服务器）</h3><p>端口映射，TP-LINK中又称为虚拟服务器，指的是我们将内网中的某一设备的某一端口映射到路由器的某一端口上，来达到外网访问的目的。适用于内网中有多设备需要被外网访问的情况。由于端口可控，所以安全性相比DMZ主机来说更高，但操作略显繁琐。</p><figure><img src="/2023/11/28/Sunshine-Moonlight-%E5%AE%9E%E7%8E%B0%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/image-9.png" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><p>在上图中我们添加了一条映射规则，映射192.168.0.100（台式机）的7210端口给路由器的7210端口，并且允许TCP/UDP两种协议数据通过。内外部端口可以不同，可以类比着添加需要的其他映射规则。</p><p>需要注意的点是开通端口映射的设备务必完成IP -MAC绑定步骤，并且不要尝试绑定外部的80和443端口。</p><p>至此我们已经完成了对路由器的全部设置，可以开始进行串流软件的安装。</p><h1 id="串流篇">串流篇</h1><h2 id="方案优势">方案优势</h2><p>在介绍Moonlight之前首先谈一谈其余的远程串流有什么缺点。</p><ol type="1"><li>Windows远程桌面：需要被串流方有公网IPv4，延迟较高，对视频、游戏的支持不好，只适合日常办公。</li><li>向日葵：需要注册账号，高级功能需要付费解锁，恼人的弹窗广告，免费版也只适合日常办公。</li><li>Pasec：需要注册账号，需要被串流方有公网IPv4。</li></ol><p>在我看来Parsec和Sunshine的远程串流质量不相上下，但Moonlight +Sunshine有让人不能拒绝的理由：</p><ol type="1"><li>跨平台：Windows、Mac、Linux、Android</li><li>丰富的编码器：H.264、H.265、AV1</li><li>公网IPv6访问</li><li>命令行指令：丰富的指令输入，拓展性极强</li></ol><p>接下来介绍这套方案的具体搭建步骤。</p><h2 id="软件安装">软件安装</h2><p>原本使用Moonlight串流只需要连接上NVIDIA的SHIELDGameStream服务就可以。但是这项服务在2023年的2月份被停止了，所以需要使用Sunshine代替这项服务的位置。</p><p>Sunshine是Github上的开源项目，项目地址：</p><p>Sunshine：<a href="https://github.com/LizardByte/Sunshine" class="uri">https://github.com/LizardByte/Sunshine</a></p><p><strong>Sunshine安装在需要被串流的设备上</strong>，这里我将它安装在我的台式机上，安装过程略过一路Next即可。</p><p>Moonlight是Github上的开源项目，项目地址：</p><p>moonlight-qt（for Windows, Mac, Linux, and Steam Link）：<a href="https://github.com/moonlight-stream/moonlight-qt" class="uri">https://github.com/moonlight-stream/moonlight-qt</a></p><p>moonlight-android：<a href="https://github.com/moonlight-stream/moonlight-android" class="uri">https://github.com/moonlight-stream/moonlight-android</a></p><p><strong>Moonlight安装在接收串流的设备上</strong>，如手机、平板、笔记本等上，Github里分为两个版本，qt适用于Windows,Mac, Linux 和 Steam Link，android自成一个版本按需下载。</p><h2 id="sunshine配置">Sunshine配置</h2><p>初次启动Sunshine，网页会提醒设置账户及密码，填入后并记住供以后使用。</p><p>大部分配置默认或按需调整即可，这里我介绍几个比较重要的设置。</p><h3 id="ipv6访问配置">IPv6访问配置</h3><figure><img src="/2023/11/28/Sunshine-Moonlight-%E5%AE%9E%E7%8E%B0%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/image-10.png" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><p>如果需要开启IPv6访问，需要在 “Configuration - Advanced - AddressFamily” 中选择 “IPv4 + IPv6”。</p><h3 id="编码器配置n卡">编码器配置（N卡）</h3><figure><img src="/2023/11/28/Sunshine-Moonlight-%E5%AE%9E%E7%8E%B0%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/image-11.png" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><p>由于我使用的是NVIDIA 30系列显卡，所以同一页面中的 “Force a SpecificEncoder” 我选择 “NVIDIA NVENC”强制使用独立显卡进行编码（而不使用CPU的核芯显卡 “Intel QuickSync”进行编码）。</p><figure><img src="/2023/11/28/Sunshine-Moonlight-%E5%AE%9E%E7%8E%B0%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/image-12.png" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><p>之后来到 “Configuration - NVIDIA NVENC Encoder” 选项卡，更改“Performance preset” 为 "P6" 、 “Two-pass mode” 为 “Full resolution(slower)” 以提高编码质量。如果出现编码过载（依照任务管理器 - GPU - VideoEncode是否满载判断）或者编码延迟过高（Moonlight性能统计中可看编码延迟，快捷键<code>ctrl + alt + shift + S</code>）可以适当降低编码质量。</p><h3 id="快速应用启动配置">快速应用启动配置</h3><p>Sunshine默认给出了Desktop和Steam的应用程序配置，这里我以 Steam 和Forza Horizon 5 为例讲解如何配置应用程序的快速启动</p><h4 id="steam">Steam</h4><ol type="1"><li>“Application Name” 填入 “Steam”（不要在Sunshine中填入任何中文字符，很有可能会导致Moonlight报Error-1错误）</li><li>“Command Preparations” 中填入一条 Undo 命令 “steam -shutdown”用于在用户退出串流后退出steam，并且勾选 “Run with Admin”。</li><li>“Detached Commands” 加入一条命令 “steam steam://open/bigpicture”用于以大屏幕模式启动Steam。</li><li>“Detached Commands” 加入一条命令 “steam -tenfoot”在Steam已启动的情况下切换为大屏幕模式（此命令在当前Steam版本下不可用）。</li><li>“Working Directory” 中填入你的Steam安装目录，如 “C:Files(x86)”。</li><li>勾选 “Run as administrator”。</li><li>Save保存。</li></ol><h4 id="forza-horzon-5">Forza Horzon 5</h4><ol type="1"><li>“Application Name” 填入 “Forza Horizon 5”（不要在Sunshine中填入任何中文字符，很有可能会导致Moonlight报Error-1错误）</li><li>“Command Preparations” 中填入一条 Undo 命令 “steam -shutdown”用于在用户退出串流后退出steam，并且勾选 “Run with Admin”。</li><li>“Detached Commands” 加入一条命令 “steam steam://rungameid/1551360”用于启动该游戏。</li><li>“Working Directory” 中填入你的Steam安装目录，如 “C:Files(x86)”。</li><li>勾选 “Run as administrator”</li><li>点击 “Find Cover”，Sunshine将根据填入的 “Application Name”自动检索目标封面，选择最适合的一个。</li><li>Save保存。</li></ol><figure><img src="/2023/11/28/Sunshine-Moonlight-%E5%AE%9E%E7%8E%B0%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/qq_pic_merged_1701247448610.jpg" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><p>完成后Moonlight中将显示所有已创建的应用。</p><p>Moonlight的配置非常简单，且都有汉化这里就不再细讲了。</p><p>到这一步应该能够实现最基本的公网串流了，实测在同市环境下网络延迟不超过20ms。</p><p>但这套方案还有很多问题需要解决：</p><ol type="1"><li>串流开始后需要手动切换分辨率及刷新率。</li><li>设备睡眠或关机后无法被唤醒。</li><li>被串流设备需要保持显示器开启才能串流画面。</li></ol><p>下面来一一介绍可行的解决方案。</p><h2 id="分辨率及刷新率自动切换">分辨率及刷新率自动切换</h2><h3 id="自建分辨率及刷新率n卡">自建分辨率及刷新率（N卡）</h3><p>Windows系统通常会预设几个常用的分辨率及刷新率，但不一定会给出你拥有的所有设备的分辨率及刷新率。</p><p>比如我的手机分辨率是 2400 * 1080 @ 120Hz，笔记本的分辨率是 2560 *1600 @ 60Hz 这些都不在预设分辨率内，所以需要自建分辨率。</p><p>首先打开NVIDIA控制面板，选择 “显示” 选项卡下的 “更改分辨率” ，点击“自定义” 按钮。</p><figure><img src="/2023/11/28/Sunshine-Moonlight-%E5%AE%9E%E7%8E%B0%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/image-13.png" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><p>在这里创建两个目标分辨率及刷新率即可。</p><figure><img src="/2023/11/28/Sunshine-Moonlight-%E5%AE%9E%E7%8E%B0%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/image-14.png" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><h3 id="自动切换插件resolutionautomation">自动切换插件ResolutionAutomation</h3><p>Github上有人为Sunshine开发了一款插件名叫<strong>ResolutionAutomation</strong>，能够在每次串流开始和结束后，自动切换被串流设备的分辨率及刷新率，以适应不同的显示设备。</p><p>项目地址：<a href="https://github.com/Nonary/ResolutionAutomation" class="uri">https://github.com/Nonary/ResolutionAutomation</a></p><p>下载后解压到任意位置，以管理员身份运行Install.bat即可。</p><p>该插件会在Sunshine中添加一个预备命令，用于执行分辨率变换脚本，最好在Sunshine的Configuration中勾选“Run as Admin” 以使用管理员权限执行。</p><figure><img src="/2023/11/28/Sunshine-Moonlight-%E5%AE%9E%E7%8E%B0%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/image-15.png" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><h2 id="设备睡眠和关机唤醒">设备睡眠和关机唤醒</h2><p>因为节电或其它种种原因，我们的设备并不会保持永远开机的状态，所以开启设备睡眠和关机唤醒功能是很有必要的。</p><h3 id="睡眠唤醒">睡眠唤醒</h3><p>首先打开 “设备管理器 - 网卡 - 属性 - 电源管理” 勾选“允许此设备唤醒计算机” 与 “只允许幻数据包唤醒计算机”。</p><figure><img src="/2023/11/28/Sunshine-Moonlight-%E5%AE%9E%E7%8E%B0%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/image-16.png" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><p>其次开启此功能还需要主板BIOS支持，这里以微星Z690主板为例。</p><figure><img src="/2023/11/28/Sunshine-Moonlight-%E5%AE%9E%E7%8E%B0%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/qq_pic_merged_1701269685282.jpg" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><p>重启电脑，按delete进入BIOS后，按F7进入高级模式，在 “高级 -唤醒事件设置” 选项卡中开启 “Resume By Intel CNVI”。</p><p>设置完成后，可以使用Moonlight自带的Wake onLan功能实现公网唤醒睡眠中的设备。</p><h3 id="关机唤醒">关机唤醒</h3><p>对于关机中的设备唤醒，网上有帖子说只需要关闭Windows的快速启动即可，但我实测没法通过这种方式唤醒，不知道是哪里出现了问题。</p><p>且这种方式有个弊端就是要求设备必须是正常关机（S5）才能被唤醒，对于意外断电导致的电脑关机则无能为力。</p><p>所以我选择使用智能插座（gosund CP5PRO）的方式，通过远程控制开关通断的方式唤醒关机状态下的电脑。</p><figure><img src="/2023/11/28/Sunshine-Moonlight-%E5%AE%9E%E7%8E%B0%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/qq_pic_merged_1701269706190.jpg" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><p>这里，依然要进入BIOS，在 “高级 - 电源管理设置” 选项卡中将“AC电源掉电再来电的状态” 设置为开机即可。</p><h2 id="息屏串流">息屏串流</h2><p>（施工中）等显卡欺骗器到了再写……</p><h1 id="总结">总结</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2023/11/23/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2023/11/23/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="kmp算法">KMP算法</h1><h2 id="理论篇">理论篇</h2><h3 id="前言">前言</h3><p>第一次接触KMP算法是在《大话数据结构》这本书上，算是这本书第一个有难度的部分，之后在B站上看了相关视频勉强弄了个半懂。</p><p>昨天在Leetcode上再次刷到了KMP——<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28.找出字符串中第一个匹配项的下标</a>，但是没法自己写出代码实现，于是又深入的学习了下如何手撕。</p><p>这下算是完全懂了，主要参考的是<a href="https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a>对应题目的章节，这里我再按照自己的理解复述一遍。</p><h3 id="什么是kmp">什么是KMP？</h3><p>KMP这个名字来自于发明这个算法的三位学者的名字首字母：Knuth，Morris和Pratt。</p><p>我还看到一个比较有意思的拼音解释，(K)快速(M)模式(P)匹配，用来形容这个算法再贴切不过了。</p><h3 id="kmp主要解决了什么问题">KMP主要解决了什么问题？</h3><p>KMP主要解决字符串的子串匹配问题。</p><p>例如：查找字符串 <code>"aabaabaafa"</code> 中是否存在字符串<code>"aabaaf"</code> 。</p><p>前一个字符串称为<strong>文本串</strong>，后一个字符串称为<strong>模式串</strong>。</p><p>遇到这样的问题，第一反应往往是双层for循环遍历两个字符串来查找是否存在这样的子串（暴力解法），如果文本串的长度记为<code>m</code> ，模式串的长度记为 <code>n</code> ，则算法的时间复杂度为<code>O(mn)</code> 。</p><p>暴力解法当然可以解决字符串匹配问题，Leetcode的28题也可以用这样的方法AC（Accept），但是有没有时间复杂度更低的算法呢？</p><p>KMP算法给出了答案，<strong><em>KMP通过记录已经匹配的字符信息，达到避免重复回溯指针的目的</em></strong>，使算法的时间复杂度能够降低至<code>O(m + n)</code> 。</p><p>那么如何记录已经匹配的字符信息呢？通过<strong>next数组</strong>。</p><p>但在介绍next数组前必须先理清几个概念，何谓<strong>前缀</strong>？何谓<strong>后缀</strong>？何谓<strong>最长相等前后缀</strong>？何谓<strong>前缀表</strong>？</p><h3 id="什么是前缀后缀">什么是前缀后缀？</h3><p>字符串的<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>。</p><p>字符串的<strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。</p><p>例如，对于字符串 <code>“abba”</code> ：</p><p>其前缀为 <code>"a"</code> 、 <code>"ab"</code> 、 <code>"abb"</code>。</p><p>其后缀为 <code>"bba"</code> 、 <code>"ba"</code> 、 <code>"a"</code>。</p><h3 id="什么是最长相等前后缀">什么是最长相等前后缀？</h3><p>有了前后缀的概念，最长相等前后缀就很容易理解了。</p><p><strong>最长相等前后缀的长度指对于某一字符串，它最大的相同前后缀长度为多少</strong>。</p><p>仍然以字符串 <code>"abba"</code> 为例，其最长相等前后缀为<code>"a"</code>，最长相等前后缀的长度为1。（而不是2，因为子串<code>“ab”</code> 不等于 <code>“ba”</code>）。</p><h3 id="什么是前缀表如何计算前缀表">什么是前缀表？如何计算前缀表？</h3><p><strong>前缀表记录了模式串中当前下标位置之前的字符串（包括当前位置）的最长相等前后缀的长度数据</strong>。</p><p>光看这句话可能有点懵，下面以模式串 <code>"aabaaf"</code>为例写一下它的前缀表。</p><table><thead><tr class="header"><th style="text-align: center;">下标</th><th style="text-align: center;">0</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th><th style="text-align: center;">4</th><th style="text-align: center;">5</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">模式串</td><td style="text-align: center;">a</td><td style="text-align: center;">a</td><td style="text-align: center;">b</td><td style="text-align: center;">a</td><td style="text-align: center;">a</td><td style="text-align: center;">f</td></tr><tr class="even"><td style="text-align: center;">前缀表</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">0</td></tr></tbody></table><p>首先将指针放置在第一个字符 <code>"a"</code> 上，此时下标为0，其<em>“当前下标位置之前的字符串（包括当前位置）”</em> 为 <code>"a"</code>，字符串 <code>"a"</code>的前后缀都为空，因此最长相等前后缀为0，前缀表中下标为0的位置填入0。<strong>因此对于所有前缀表，其下标为0的位置都可以直接填入0</strong>；</p><p>之后将指针放置在第二个字符 <code>"a"</code> 上，此时下标为1，其<em>“当前下标位置之前的字符串（包括当前位置）”</em> 为 <code>"aa"</code>，字符串 <code>"aa"</code>的最长相等前后缀长度为1，前缀表中下标为1的位置填入1。</p><p>依此类推，我们可以看着模式串将前缀表填写完整。</p><h3 id="前缀表和next数组有什么关系">前缀表和next数组有什么关系？</h3><p>这是个困扰了我很久的问题，因为不同的人对next数组有不同的讲法。</p><p>程杰在《大话数据结构》里给出的next数组和nextval数组我到现在都没看明白，各种考研辅导老师和视频里给出的next数组定义也很不统一，一会要整体右移并且第一个位置赋-1，一会要统一减一，绕的很晕。但是代码随想录的卡尔在他的<a href="https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E6%80%9D%E8%B7%AF">文章</a>和<a href="https://www.bilibili.com/video/BV1PD4y1o7nd">视频</a>里解释的很清楚，我再在这里陈述一遍。</p><p><strong><em>next数组可以就是前缀表本身</em></strong>，也可以是整体右移一位第一位赋值-1，还可以是整体减一。无论采用何种next数组都只是KMP算法实现细节，不涉及原理性的东西。</p><p>所以在这里<strong>我们选择使next数组即为前缀表本身</strong>，这种方法更接近KMP的实现原理（前缀表），更方便我们记忆。</p><h3 id="next数组前缀表有什么作用">next数组（前缀表）有什么作用？</h3><p>到现在为止我们已经掌握了一项技能，就是看着模式串写出前缀表，即写出next数组。</p><p>next数组之所以叫next，是因为当文本串指针与模式串指针所指字符不匹配时，可以根据next数组回溯模式串指针到新的位置来继续匹配，而不必总是回到模式串头位置。</p><h3 id="next数组前缀表为何能回溯模式串指针">next数组（前缀表）为何能回溯模式串指针？</h3><p>首先我们先看一下文本串 <code>"aabaabaafa"</code> 是如何查找模式串<code>"aabaaf"</code> 的。</p><figure><img src="/2023/11/23/KMP%E7%AE%97%E6%B3%95/image.gif" alt="KMP匹配过程"><figcaption aria-hidden="true">KMP匹配过程</figcaption></figure><p>文本串指针和模式串指针分别从各自字符串的头部开始一一向后比较，前五个字符<code>"aabaa"</code> 都能够匹配，此时移动到第六个字符发现不匹配。</p><p>到这一步，暴力（或称朴素）算法就要将文本串指针回溯到第二个字符，模式串指针回溯到第一个字符重新开始匹配了。</p><p>而KMP的模式串指针由 <code>"f"</code> 回溯至<code>"b"</code>，而文本串指针不动等待继续匹配，KMP的优越性就体现出来了。</p><p>那么为什么模式串指针要从 <code>"f"</code> 回溯至<code>"b"</code>呢？</p><table><thead><tr class="header"><th style="text-align: center;">下标</th><th style="text-align: center;">0</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th><th style="text-align: center;">4</th><th style="text-align: center;">5</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">模式串</td><td style="text-align: center;">a</td><td style="text-align: center;">a</td><td style="text-align: center;">b</td><td style="text-align: center;">a</td><td style="text-align: center;">a</td><td style="text-align: center;">f</td></tr><tr class="even"><td style="text-align: center;">前缀表</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">0</td></tr></tbody></table><p>以下这句话，对于理解为什么前缀表可以告诉我们匹配失败之后跳到哪里重新匹配，非常重要！</p><p><strong>下标5之前这部分的字符串（也就是字符串<code>"aabaa"</code>）的最长相等的前后缀是子串<code>"aa"</code>，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面，并从这个位置重新匹配就可以了。</strong></p><p>所以前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力。</p><p>但如果新的模式串所指字符依然与文本串指针所指字符不同又当如何呢？</p><p>那我们继续重复上述过程，当前模式串下标为2，查询<code>next[2 - 1]</code>的值为1，将模式串的指针回溯到下标为1的位置，即第二个字符<code>'a'</code> 。</p><p>如果一直无法与文本串指针所指字符匹配（模式串指针指向下标0位），那么文本串指针向后移一位。</p><h3 id="kmp算法匹配过程总览">KMP算法匹配过程总览<a id="x1"></a></h3><figure><img src="/2023/11/23/KMP%E7%AE%97%E6%B3%95/image-2.gif" alt="KMP算法匹配过程总览"><figcaption aria-hidden="true">KMP算法匹配过程总览</figcaption></figure><p>这下我们大概了解了KMP的匹配过程，再来回顾一下：</p><ol type="1"><li>首先我们需要根据模式串写出next数组（前缀表）。</li><li>之后我们让<strong>文本串指针i</strong>与<strong>模式串指针j</strong>同时从各自字符串头部开始向后遍历。</li><li>一旦遇到字符不匹配的情况我们根据 <code>next[j - 1]</code>的值将模式串指针j回溯到对应的下标位置，而文本串指针i不做变化。直到找到新的能够匹配的模式串指针，则继续向后匹配；或者j回溯到0位也没有遇到能匹配i所指的字符，那么文本串指针i向后移一位（++i）重新匹配。</li><li>如果循环到某个位置，模式串的所有字符都匹配完成了，则表示能够在文本串中找到对应子串；反之，若文本串指针i走到文本串的末尾也没能匹配完所有的模式串字符，则表示不能在文本串中找到对应子串。</li></ol><p>至此大功告成！</p><h3 id="kmp算法的时间复杂度分析">KMP算法的时间复杂度分析</h3><p>如果文本串的长度记为 <code>m</code> ，模式串的长度记为<code>n</code>。</p><p>在最差情况下（模式串在文本串的末尾才能被匹配），暴力的双for循环时间复杂度为<code>O(mn)</code> 。</p><p>而KMP只需要遍历一次文本串<code>O(m)</code>和生成next数组<code>O(n)</code>，总的时间复杂度为<code>O(m + n)</code>。</p><p>因此KMP算法可以极大地提高检索效率。</p><hr><h2 id="代码篇c">代码篇（C++）</h2><h3 id="前言-1">前言</h3><p>Leetcode上的题目 <a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28.找出字符串中第一个匹配项的下标</a>是练习KMP代码的最佳实践，这里就从此题出发介绍KMP代码的实现。</p><blockquote><p><strong>给你两个字符串 haystack 和 needle ，请你在 haystack字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果needle 不是 haystack 的一部分，则返回-1。</strong></p><p><strong>示例</strong> 1： 输入：haystack = "sadbutsad", needle ="sad" 输出：0 解释："sad" 在下标 0 和 6 处匹配。 第一个匹配项的下标是 0，所以返回 0 。</p><p><strong>示例</strong> 2： 输入：haystack = "leetcode", needle ="leeto" 输出：-1 解释："leeto" 没有在 "leetcode" 中出现，所以返回 -1。</p></blockquote><h3 id="kmp算法的代码套路">KMP算法的代码套路</h3><p>根据我们在<a href="#x1">理论篇 -KMP算法匹配过程总览</a>中的介绍，实现KMP算法需要两个函数，其中一个用来计算next数组，另一个用来匹配模式串。</p><p>根据我的观察这两个函数的书写都有如下的固定套路：</p><ol type="1"><li>初始化</li><li>处理两指针所指字符不等情况</li><li>处理两指针所指字符相等情况</li></ol><p>在理解的基础上记住这三步走就能轻松手撕KMP。</p><h3 id="getnext函数的实现">getNext()函数的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span> </span>&#123;<br>    <span class="hljs-comment">//初始化：next[0] = 0，j为前缀尾指针，i为后缀尾指针</span><br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-comment">//处理两指针所指字符不同情况</span><br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[j] != s[i]) &#123;<br>            j = next[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">//处理两指针所指字符相同情况</span><br>        <span class="hljs-keyword">if</span> (s[j] == s[i]) ++j;<br>        next[i] = j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>为什么选择返回类型为 <code>void</code>的函数，并且多传入一个空的next数组？</em></p><p>因为C++不允许函数返回一个完整的数组，所以我的第一想法是返回指向next数组的<code>int*</code> 指针，但如果这个指针指向 <code>getNext()</code>作用域内的局部数组，那么当函数结束时，该指针将成为一个野指针，继续在外部调用这个指针可能会导致未定义行为（虽然我这样写了leetcode没有报错，但仍然不建议这么做）。</p><p>如果我们不想从外部传入一个next数组，那么还有两种方法：</p><ol type="1"><li>一种方法就是在函数内部定义一个静态数组。但我们需要一个变量<code>s.size()</code>来确定静态数组的大小，C++不允许声明一个可变大小的静态数组，所以此方案不可行。</li><li>另一种方法是使用动态分配数组（ <code>new int[]</code>），但这种方法有个缺点是需要在主函数（匹配函数）中手动回收内存（<code>delete []</code> ），会让主函数看起来很乱。</li></ol><p>所以最好的方法还是在主函数中声明一个空next数组，之后通过指针传递到getNext()函数中。</p><p>可以在菜鸟学习更多<a href="https://www.runoob.com/cplusplus/cpp-return-arrays-from-function.html">C++从函数返回数组</a>内容。</p><h4 id="初始化">1. 初始化</h4><p>在这一阶段我们初始化了两个指针，<strong>j为前缀尾指针</strong>初始指向下标0位，<strong>i为后缀尾指针</strong>初始指向下标1位；并且将next[0]初始化为0（首字符不存在相等前后缀）。接下来我们遍历后缀尾指针i，在不断地遍历中填充next数组。</p><h4 id="处理两指针所指字符不等情况">2. 处理两指针所指字符不等情况</h4><p>在这种情况下我们对 <code>s[j]</code> 和 <code>s[i]</code>内容进行比较，发现两者不相同，那么前缀尾指针j就要回退，退到哪里呢？</p><p>我们回头看next数组， <code>next[j - 1]</code>中所存储的数字表示从模式串头部到下标为 <code>j - 1</code>的位置的字串的最长相等前后缀长度。那我们跳回到下标为<code>next[j - 1]</code> 的位置，那么现在的新前缀尾位置<code>j = next[j - 1]</code>会和匹配失败时的前缀尾位置之前的字符串完全相同。</p><p>当然，有可能一次回退后 <code>s[j]</code> 与 <code>s[i]</code>仍然不相等，所以这条语句不能是 <code>if</code> 而应该是<code>while</code>；同时我们不能允许j无限制的回退，所以<code>while</code> 循环里加上一条限制<code>j &gt; 0</code>，如果最后j都等于0了仍然匹配不了 <code>s[j]</code>和 <code>s[i]</code>，那我们记 <code>next[i] = 0</code>，同时放弃匹配当前的后缀尾指针所指字符 <code>s[i]</code> 。</p><h4 id="处理两指针所指字符相等情况">3. 处理两指针所指字符相等情况</h4><p>在这种情况下我们对 <code>s[j]</code> 和 <code>s[i]</code>内容进行比较，发现两者相同，那么前缀尾指针j就要向后移一位；</p><p>同时不要忘了将新的next数组值 <code>j</code>存储到next数组的后缀尾指针所指位置 <code>next[i]</code> ；</p><p>流程走完后回到for循环，后缀尾指针i将向后移动。</p><h4 id="总结">总结</h4><p>写 <code>getNext()</code>函数关键就是理解前缀尾指针j的含义，j的值反映了模式串中头字符到当前下标位置的字符（包括当前位置）中最长相等前后缀的长度。</p><h3 id="匹配函数strstr的实现">匹配函数strStr()的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123; <span class="hljs-comment">//haystack文本串，needle模式串</span><br>    <span class="hljs-comment">//初始化：next数组，i为文本串指针，j为模式串指针</span><br>    <span class="hljs-type">int</span> next[needle.<span class="hljs-built_in">size</span>()];<br>    <span class="hljs-built_in">getNext</span>(next, needle);<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; haystack.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-comment">//处理两指针所指字符不同情况</span><br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;<br>            j = next[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">//处理两指针所指字符相同情况</span><br>        <span class="hljs-keyword">if</span> (haystack[i] == needle[j]) ++j;<br>        <span class="hljs-keyword">if</span> (j == needle.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> (i - needle.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="初始化-1">1. 初始化</h4><p>使用getNext()函数取得next数组；使<strong>文本串指针i</strong>初始化到文本串头部，<strong>模式串指针j</strong>初始化到模式串头部；使用for循环遍历文本串。</p><h4 id="处理两指针所指字符不等情况-1">2. 处理两指针所指字符不等情况</h4><p>观察下这部分的代码可以发现跟 <code>getNext()</code>第二部分是及其相似的，不同的地方只有while循环的判断条件更改了。</p><p>当文本串指针i所指字符与模式串指针j所指字符不等时，需要查找<code>next[j - 1]</code>的值来回溯模式串指针j，直到回溯到下标为0的位置或发现匹配的字符。</p><h4 id="处理两指针所指字符相等情况-1">3. 处理两指针所指字符相等情况</h4><p>如果两指针所指字符相等那么很简单，文本串指针i（隐藏在for循环的<code>++i</code> 中）和模式串指针j都自增一次。</p><p>如果模式串的最后一个字符被匹配，那么j将等于模式串的长度（注意字符串下标是从0开始），这时通过公式<code>i - needle.size() + 1</code>可以得到文本串与模式串匹配的第一个下标。</p><p>如果直到for循环结束（遍历完整个文本串）都没能找到完全匹配模式串的子串，那么直接<code>return -1</code> 表示未找到匹配的子串。</p><h3 id="完整代码">完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123; <span class="hljs-comment">//haystack文本串，needle模式串</span><br>        <span class="hljs-comment">//初始化：next数组，i为文本串指针，j为模式串指针</span><br>        <span class="hljs-type">int</span> next[needle.<span class="hljs-built_in">size</span>()];<br>        <span class="hljs-built_in">getNext</span>(next, needle);<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; haystack.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-comment">//处理两指针所指字符不同情况</span><br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (haystack[i] == needle[j]) ++j;<br>            <span class="hljs-keyword">if</span> (j == needle.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> (i - needle.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//处理两指针所指字符相同情况</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span> </span>&#123;<br>        <span class="hljs-comment">//初始化：next[0] = 0，j为前缀尾指针，i为后缀尾指针</span><br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-comment">//处理两指针所指字符不同情况</span><br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[j] != s[i]) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">//处理两指针所指字符相同情况</span><br>            <span class="hljs-keyword">if</span> (s[j] == s[i]) ++j;<br>            next[i] = j;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结-1">总结</h2><p>这篇文章从理论和代码两方面介绍了KMP算法。</p><p>理论篇以问题环环相扣的方式，试着让理解KMP算法有一个清晰的顺序，并采用了一种明晰的next数组定义方式——直接取为前缀表，方便理解和记忆。</p><p>代码篇总结了 <code>strSte()</code> 和 <code>getNext()</code>两个函数的共同点，给出了KMP代码的一般套路，在理解的基础上记忆能够很快地手撕出KMP。</p><p>写这篇不到7k字的文章用了整整一天，有些过于耗时了。不过我本人在写这篇文章的过程中的确收获颇丰，对KMP算法有了更深层次地理解，同时也锻炼了文字表达能力，在Leetcode上第四次手撕KMP也成功在5分钟内一次AC，共勉！</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>算法</tag>
      
      <tag>KMP</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode59.螺旋矩阵 II</title>
    <link href="/2023/11/20/Leetcode59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II/"/>
    <url>/2023/11/20/Leetcode59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II/</url>
    
    <content type="html"><![CDATA[<h1 id="螺旋矩阵-ii">59. 螺旋矩阵 II</h1><blockquote><p>给你一个正整数 <code>n</code> ，生成一个包含 1 到 <span class="math inline">\(n^2\)</span>所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code>正方形矩阵。</p><figure><img src="/2023/11/20/Leetcode59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II/image.png" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><blockquote><p><strong>示例 1：</strong> <strong>输入：</strong> n = 3<strong>输出：</strong> [[1,2,3],[8,9,4],[7,6,5]]</p></blockquote><p><strong>示例 2：</strong> <strong>输入：</strong> n = 1<strong>输出：</strong> [[1]]</p><p><strong>提示：</strong> · 1 &lt;= n &lt;= 20</p></blockquote><h2 id="解题思路">解题思路</h2><p>初始化一个 <code>n×n</code> 大小的矩阵<code>mat</code>，然后模拟整个向内环绕的填入过程：</p><p>1.定义当前左右上下边界 <code>l,r,t,b</code>，初始值<code>num = 1</code>，迭代终止值 <code>tar = n * n</code>；</p><p>2.当 <code>num &lt;= tar</code>时，始终按照从左到右、从上到下、从右到左、从下到上的填入顺序循环，每次填入后：a.执行 <code>num += 1</code>：得到下一个需要填入的数字；b.更新边界：例如从左到右填完后，上边界<code>t += 1</code>，相当于上边界向内缩1。</p><p>3.使用<code>num &lt;= tar</code>而不是<code>l &lt; r || t &lt; b</code>作为迭代条件，是为了解决当n为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。</p><p>4.最终返回 <code>mat</code> 即可。</p><figure><img src="/2023/11/20/Leetcode59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II/image-1.png" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><p>作者：Krahets链接：https://leetcode.cn/problems/spiral-matrix-ii/solutions/12594/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>, l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>, b = n - <span class="hljs-number">1</span>; <span class="hljs-comment">//定义初始上、左、右、下边界</span><br>        <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">res</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n)); <span class="hljs-comment">//定义一个二维vector存储结果</span><br>        <span class="hljs-keyword">while</span> (num &lt;= n * n) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; ++i) res[t][i] = num++;<br>            ++t; <span class="hljs-comment">//上边界下移</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = t; i &lt;= b; ++i) res[i][r] = num++;<br>            --r; <span class="hljs-comment">//右边界左移</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r; i &gt;= l; --i) res[b][i] = num++;<br>            --b; <span class="hljs-comment">//下边界上移</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = b; i &gt;= t; --i) res[i][l] = num++;<br>            ++l; <span class="hljs-comment">//左边界右移</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>看起来边界条件复杂的一道题目，经过K神的简化能写得如此清晰、优美，着实让人五体投地。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图灵停机问题</title>
    <link href="/2023/11/20/%E5%9B%BE%E7%81%B5%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98/"/>
    <url>/2023/11/20/%E5%9B%BE%E7%81%B5%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>这个问题来自于我前两天看的一个视频<a href="https://www.bilibili.com/video/BV1EW411u7th">【计算机科学速成课】</a>P15阿兰·图灵一节。小姐姐把问题阐述的很清楚，但即使有动画图解我仍然无法理解证明方法。以下给出我在知乎上看到一个答主给的<a href="https://zhuanlan.zhihu.com/p/653811654">总结</a>。</p><h1 id="何谓停机问题">1. 何谓“停机问题”？</h1><p><strong>给定图灵机描述和输入，是否有算法可以确定机器会永远计算下去（死循环）还是会到某一时刻停机？</strong></p><p>一个例子就是如果我写了一个程序，是否可以通过某一程序事先确定我写的程序是会陷入死循环还是能够正常结束？</p><p>答案是否定的，以下是反证法的证明。</p><h1 id="停机自动判定程序h">2. 停机自动判定程序H</h1><p>为了沟通方便，事先约定如下：</p><p>设一个程序为P，运行时需要传入一个参数，若要运行它，则这么表示：</p><p><code>P(参数)</code></p><p>而如果想强调这一程序的代码本身，则记为：</p><p><code>[P]</code></p><p>停机自动判定程序记作H，它应该有两个参数。参数1：待判定程序P；参数2：运行P程序时的传入参数。（对于某个需要参数的程序P，不能单纯地说它会不会停机。有可能传入101时会停机，而传入42后又陷入死循环了，所以传入参数不能省略。）</p><p>所以，以下给出H的使用范例：</p><p>如果P(42)会死循环不停机，那么H([P], 42)返回false；</p><p>如果P("apple")会停机，那么H([P], "apple")返回true。</p><h1 id="反证法">3. 反证法</h1><p>图灵首先定义了一个跟H对着干的程序U，代码如下：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs wren">定义程序 <span class="hljs-title function_">U</span>(参数)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">H</span>(参数, 参数) <span class="hljs-operator">==</span> <span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;&#125; <span class="hljs-comment">//死循环</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简略解释以下，如果停机自动判定程序H返回true，那么就让程序U陷入死循环；如果H返回false，那就返回true。</p><p>那么如果将U的代码数据传入U中，那么就变成了：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs wren">定义程序 <span class="hljs-title function_">U</span>([<span class="hljs-params">U</span>])<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">H</span>([<span class="hljs-variable">U</span>], [<span class="hljs-variable">U</span>]) <span class="hljs-operator">==</span> <span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;&#125; <span class="hljs-comment">//死循环</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="分析">4. 分析</h1><p>① H([U],[U])返回true意味着，停机自动判定程序H认为U([U])这个程序能够正常停机。但如果程序U([U])进入了当前的if分支则会陷入死循环而无法正常停机，矛盾！</p><p>② H([U],[U])返回false意味着，停机自动判定程序H认为U([U])这个程序会陷入死循环。同理，如果程序U([U])进入了当前的else分支则会返回true正常停机，再次矛盾！</p><p>双重矛盾表明，“停机自动判定程序H”根本不存在。</p><h1 id="总结">5. 总结</h1><p>停机问题的反证法很巧妙，精髓在于想出来<code>U(参数)</code>和<code>H(参数, 参数)</code>的互相转换和<code>[U]</code>的代入。</p>]]></content>
    
    
    <categories>
      
      <category>计算机科学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Essential C++》读书笔记</title>
    <link href="/2023/09/22/%E3%80%8AEssential%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/09/22/%E3%80%8AEssential%20C++%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>Lippman在前言部分明确的阐明了本书的写作目的：“C++Primer第三版其实无法扮演人们在初学C++时的导师角色。它太庞大了”。</p><h2 id="结构与组织">结构与组织</h2><p>结构与组织部分可能很好的说明了此书的组织架构，但我现在还看不懂，就先不重复了。之后会讲每一部分的内容附加到相应章节之前。</p><h2 id="关于源代码">关于源代码</h2><p>本书所有的程序，以及习题解答中的完整代码，都可以从网上获得。可以在<a href="https://www.informit.com/store/essential-c-plus-plus-9780201485189">AddisonWesley的网站</a>或<a href="http://www.broadview.com.cn/book/4437">博文视点网站</a>取得。</p><h1 id="第1章-c编程基础">第1章 C++编程基础</h1><p>第1章借着撰写一个具有互动性质的小程序，描绘C++语言预先定义的部分。这一章涵盖了内置的数据类型、语言预定义的运算符（operator）、标准库中的<em>vector</em>和<em>string</em>、条件语句和循环语句、输入和输出用的iostream库。</p><h2 id="如何撰写c程序">1.1 如何撰写C++程序</h2><ul><li><p>每个C++程序都是从一个名为<strong>main</strong>的函数开始执行，其通用形式如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>习惯上，程序执行无误时我们令main()返回零。若返回一个非零值，表示程序在执行过程中发生了错误。</p></li><li><p>C++标准的“输入/输出库”名为iostream，用以支持对终端和文件的输入与输出。</p></li><li><p>如果没有在main()的末尾写下return语句，<code>return 0</code>将会被自动加上。</p></li><li><p>第一个完整的C++程序： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">string</span> user_name;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Please enter your first name:&quot;</span>;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; user_name;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span> &lt;&lt; <span class="hljs-string">&quot;Hello, &quot;</span> &lt;&lt; user_name &lt;&lt; <span class="hljs-string">&quot; ... and goodbye!\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ul><h2 id="对象的定义和初始化">1.2 对象的定义和初始化</h2><ul><li>对象的名称可以是任何字母、数字、下划线（underscore）的组合。</li><li>对象的名称不能以数字开头。</li><li>任何命名不能和程序语言本身的关键字一致。</li><li>const关键字用来表示常量的对象。</li></ul><h2 id="撰写表达式">1.3 撰写表达式</h2><ul><li>四种运算符：算术运算符、关系运算符、逻辑运算符、复合赋值运算符</li><li>条件运算符的一般形式： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">expr</span><br>    ? 如果<span class="hljs-built_in">expr</span>为<span class="hljs-literal">true</span>，就执行这里<br>    : 如果<span class="hljs-built_in">expr</span>为<span class="hljs-literal">false</span>，则执行这里<br></code></pre></td></tr></table></figure></li><li>OR逻辑运算符（||）可以同时检验多个表达式的结果。左侧表达式会被先求值，如果其值为<code>true</code>，剩下的另一个表达式就不需要再被求值（此所谓<strong>短路求值法</strong>）。### 运算符优先级（优先级从上到下）</li></ul><ol type="1"><li>逻辑运算符NOT</li><li>算术运算符（*, /, %）</li><li>算术运算符（+, -）</li><li>关系运算符（&lt;, &gt;, &lt;=, &gt;=）</li><li>关系运算符（==, !=）</li><li>逻辑运算符AND</li><li>逻辑运算符OR</li><li>赋值运算符</li></ol><ul><li>如果想要改变内置的运算符优先级，可利用小括号。</li><li>运算优先级是C++变成之所以复杂的原因之一。</li></ul><h2 id="条件语句和循环语句">1.4 条件语句和循环语句</h2><h3 id="条件语句">条件语句</h3><ul><li>switch语句中break的用途：当某个标签和switch表达式值吻合时，该case标签之后的所有case标签也都会被执行，除非我们明确使用break来结束执行。### 循环语句</li></ul><h2 id="如何运用array和vector">1.5 如何运用Array和Vector</h2><ul><li>一般建议使用vector甚于array。</li><li>array和vector之间存在一点差异，那就是vector知道自己的大小是多少。（vector.size()）</li></ul><h2 id="指针带来弹性">1.6 指针带来弹性</h2><ul><li>指针主要做两件事，它可以增加程序本身的弹性，但同时增加了直接操作对象时所没有的复杂度。</li><li>下述写法可以将<code>pi</code>的初值设置为<code>ival</code>所在的内存地址<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *pi = &amp;ival<br></code></pre></td></tr></table></figure></li><li>提领（dereference）操作——就是取得“位于该指针所指内存地址上”的对象。在指针之前使用<code>*</code>号，便可以达到这个目的。</li><li>指针的复杂度源于它的双重性质：既可以操作指针包含的内存地址，又可以操作指针所指的对象值。</li><li>指针第二个可能令人感到复杂的地方是：在使用指针时，必须在提领之前确定它的确指向某对象。</li><li>一个未指向任何对象的指针，其地址值为0。有时候我们称之为null指针。</li><li>如果要通过指针来选择操作，必须用arrow（-&gt;）而非dot（.）成员选择运算符。</li></ul><h2 id="文件的读写">1.7 文件的读写</h2><ul><li>要对文件进行读写操作，首先得包含fstream文件。</li></ul><h1 id="第2章-面向过程的编程风格">第2章 面向过程的编程风格</h1><p>第2章解释函数的设计与使用，并逐一查看C++函数的多种不同风貌，包括inline函数、重载（<em>overloaded</em>）函数、functiontemplate，以及函数指针（pointers to <em>functions</em>）。</p><h2 id="如何编写函数">2.1 如何编写函数</h2><ul><li>每一个函数必须定义以下四个部分：<ol type="1"><li>返回类型</li><li>函数名</li><li>参数列表</li><li>函数体</li></ol></li><li>函数必须先被声明，然后才能被调用（被使用）。函数声明不必提供函数体，但必须明确返回类型、函数名，以及参数列表。</li></ul><h2 id="调用函数">2.2 调用函数</h2><ul><li><strong>冒泡排序</strong>：由两个嵌套的for循环实现。外层的for循环一次以ix为索引遍历vector内的元素，其值由0递增至size-1；内层的for循环以jx为索引从ix+1依次递增至size-1；并且同时比较vector中ix和jx处两元素的值，如果jx处的元素小则将其互换。</li><li>传值（pass byvalue）：当我们将vec[ix]这样的对象传入函数，默认情形下其值会被复制一份，成为参数的局部性定义（localdefinition）。</li><li>传址（pass byreference）：令函数的参数和传入的实际对象产生关联。要达成这个目的，最简单的做法就是将参数声明为一个reference。</li></ul><h3 id="pass-by-reference语义">Pass by Reference语义</h3><ul><li>当我们以byreference的方式将对象作为函数参数传入时，对象本身并不会复制出另一份——复制的是对象的地址。</li><li>将参数声明为reference有两个理由：①希望的一直接对所传入的对象进行修改。②降低复制大型对象的负担。</li><li>一般来说，除非希望在函数内修改参数值，否则建议在传递内置类型时，不要使用传址方式。传址机制主要用于传递classobject。</li></ul><h3 id="作用域">作用域</h3><ul><li>除了一个必要的例外（static），函数内定义的对象，只存在于函数执行期间。</li><li>为对象分配的内存，其存活时间成为储存器（storageduration）或范围（extent）。</li><li>对象在程序内的存活区域成为该对象的作用域（scope）</li><li>对象如果在函数之外声明，则具有所谓的file scope。对象如果拥有filescope，从其声明点至文件末尾都是可见的。</li><li>内置类型的对象，如果定义在filescope内，必定被初始化为0。但如果它们被定义于localscope之内，那么除非程序员指定其初值，否则不会被初始化。</li></ul><h3 id="动态内存管理">动态内存管理</h3><ul><li>除了local scope和file scope，还有一种储存其形式成为dynamicextent（动态范围）。其内存有程序的空闲空间（freestore）分配而来，有时也称为heapmemory（堆内存）。这种内存必须由程序员自行管理，其分配通过new来完成，释放通过delete表达式完成。</li><li>由于某种原因，程序员不想使用delete表达式，由heap分配而来的对象就永远不会被释放，这称为内存泄漏（memoryleak）。</li></ul><h2 id="提供默认参数">2.3提供默认参数</h2><ul><li>默认参数值的提供有两个不直观的规则：<ol type="1"><li>默认值的解析（resolve）操作由最右边开始进行。如果我们为某个参数提供了默认值，那么这一参数右侧的所有参数都必须也具有默认参数才行。下面这样实属非法：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//错误：没有为vec提供默认值</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">( ostream &amp;os = <span class="hljs-built_in">cout</span>, <span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; &amp;vec)</span>;<br></code></pre></td></tr></table></figure></li><li>默认值只能指定一次，可以在声明处，亦可在函数定义处，但不能够在两个地方都指定。（头文件可为函数带来更高的可见性（visibility）为了更高的可见性，我们决定将默认值放在函数声明处而非定义处。）</li></ol></li></ul><h2 id="使用局部静态对象">2.4 使用局部静态对象</h2><ul><li>为了节省函数见的通信问题而将对象定义于filescope中，永远都是一种冒险。通常，filescope对象会打乱不同函数间的独立性，使它们难以理解。</li><li>局部静态对象所处的内存空间，即使在不同的函数调用过程中，依然持续存在，这也就是我们可以安全地返回其地址的原因。</li></ul><h2 id="声明inline函数">2.5 声明inline函数</h2><ul><li>将函数声明为inline，表示要求编译器在每个函数调用点上，将函数内容展开。面对一个inline函数，编译器可将该函数的调用操作改为以一份函数代码副本代替。这将是我们获得性能改善，其结果是把多个函数写入一个函数中，但依然维持三个独立的运算单元。</li><li>一般而言，最适合声明为inline1的函数具有如下特征：体积小、常被调用、所从事的计算并不复杂。</li><li>inline函数的定义常被放在头文件中。</li></ul><h2 id="提供重载函数">2.6 提供重载函数</h2><ul><li><strong>函数函数</strong>：参数列表（parameterlist）不相同（可能是参数类型不同，可能是参数个数不同）的两个或多个函数，可以拥有相同的函数名称。</li><li>编译器无法根据函数返回类型来区分两个具有相同名称的函数。</li><li>将一组实现代码不同但工作内容相似的函数加以重载，可以让用户更容易使用这些函数。如果没有重载机制，我们就得为每个函数提供不同的名称。</li></ul><h2 id="定义并使用模板函数">2.7 定义并使用模板函数</h2><ul><li><strong>函数模板</strong>（functiontemplate）的机制：将单一函数的内容与希望显示的各种类型绑定（bind）起来。</li><li>一般而言，如果函数具备多种实现方式，我们可将它重载（overload），其每份实力提供的是相同的通用服务。如果我们希望让程序代码的主体不变，仅仅改变其中用到的数据类型，可以通过functiontemplate达到目的。</li></ul><h2 id="函数指针带来更大的弹性">2.8 函数指针带来更大的弹性</h2><ul><li>函数指针（pointer tofunction）必须指明其所指函数的返回类型及参数列表；函数的定义必须将*放在某个位置，表示这份定义所表现的是一个指针；最后还必须给予一个名称。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;* (*seq_ptr)( <span class="hljs-type">int</span> );<br></code></pre></td></tr></table></figure></li></ul><h2 id="设定头文件">2.9 设定头文件</h2><ul><li>函数的定义只能有一份。</li><li>但上述规则有一个例外——inline函数的定义。为了能够扩展inline函数的内容，在每个调用点上，编译器都得取得其定义。这意味着我们必须将inline函数的定义放在头文件中，而不是把它放在不同的程序代码文件中。</li><li>在filescope内定义的对象，如果可能被多个文件访问，就应该被声明于头文件中。</li><li>下述对象的声明并不完全正确： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> seq_cnt = <span class="hljs-number">6</span>;<br><span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;* (*seq_array[seq_cnt])( <span class="hljs-type">int</span> );<br></code></pre></td></tr></table></figure>需要在<code>seq_array</code>定义前加上关键字<code>extern</code>，便成为一个声明<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> seq_cnt = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;* (*seq_array[seq_cnt])( <span class="hljs-type">int</span> );<br></code></pre></td></tr></table></figure></li><li>为什么上述代码块中的<code>seq_cnt</code>不需要extern修饰？<br>因为const object和inline函数一样，是“一次定义”规则下的例外。constobject的定义只要一处文件之外便不可见。</li><li>引用头文件何时使用<code>&lt;&gt;</code>何时使用<code>""</code>包裹？<br>如果头文件和包含此文件的程序代码文件位于同一个磁盘目录下，便用<code>""</code>。否则，用<code>&lt;&gt;</code>。</li></ul><h1 id="第3章-泛型编程风格">第3章 泛型编程风格</h1><p>第3章涵盖了所谓的Standard TemplateLibrary（STL）：一组容器类（包括vector、list、set、map，等等）、一组作用于容器上的泛型算法（包括sort()、copy()、merge()，等等）。附录B按字典顺序列出了最广为运用的泛型算法，并逐一列上了使用实例。*泛型算法提供了许多可作用于容器类及数组类型上的操作。这些算法之所以被称为泛型（generic），是因为它们和它们想要操作的元素类型无关。</p><h2 id="指针的算术运算">3.1 指针的算术运算</h2><ul><li>数组最后一个元素的下一个地址，扮演者我们所说的标兵的角色，用以指示我们的迭代操作何时完成。</li><li>指针的算术运算并不适用于list，因为指针的算术运算必须首先假设所有元素都储存在连续空间里，然后才能根据当前的指针，加上元素大小之后，指向下一个元素。</li></ul><h2 id="了解iterator泛型指针">3.2 了解Iterator（泛型指针）</h2><ul><li>如何取得iterator？每个标准容器都提供有一个名为begin()的操作函数，可返回一个iterator，指向第一个元素。另一个名为end()的操作函数会返回一个iterator，指向最后一个元素的下一个位置。因此，不论如何定义iterator对象，一下都是对iterator进行赋值（assign）、比较（compare）、递增（increment）、提领（dereference）操作：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (iter = svec.<span class="hljs-built_in">begin</span>(); iter != svec.<span class="hljs-built_in">end</span>(); ++iter)<br>    cout &lt;&lt; *iter &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br></code></pre></td></tr></table></figure></li><li>iterator的定义形式： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; svec;<br>vector&lt;string&gt;::iterator iter = svec.<span class="hljs-built_in">begin</span>();<br></code></pre></td></tr></table></figure>此处iter被定义为一个iterator，指向一个vector，后者的元素类型为string。其初值指向svec的第一个元素。双冒号表示此iterator乃是位于stringvector定义内的嵌套[<em>nested</em>]类型。</li><li>如果要通过iter调用底部的string元素所提供的操作，我们可以使用arrow（箭头）运算符：<code>cout &lt;&lt; "(" &lt;&lt; iter-&gt;size() &lt;&lt; "):" &lt;&lt; *iter &lt;&lt; endl;</code></li></ul><h2 id="所有容器的共通操作">3.3 所有容器的共通操作</h2><p>下列为所有容器类（包括string类）的共通操作： * equality (==)和inequality (!=) 运算符，返回true或false。 * assignment(=)运算符，将某个容器复制给另一个容器。 *empty()会在容器无任何元素时返回true，否则返回false。 *size()返回容器内目前持有的元素个数。 * clear()删除所有元素。</p><h2 id="使用顺序性容器">3.4 使用顺序性容器</h2><ul><li>顺序型容器用来维护一组排列有序、类型相同的元素。</li><li>vector用一块连续内存来存放元素。随机访问颇有效率，但插入或删除非末位元素缺乏效率。</li><li>list系以双向链接（double-linked）而非连续内存来存储内容。任意位置插入或删除颇有效率，随机访问缺乏效率。</li><li>deque（读作deck）和vector一样用连续内存存储元素。不同的是其两端插入和删除的效率都很高。</li><li>vector允许末端插入（push_back()）和删除(pop_back())操作。list和deque在此基础上允许前端插入（push_front()）和删除（pop_front()）。</li><li>list不支持iterator偏移运算： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//错误：list并不支持iterator偏移运算</span><br>list.<span class="hljs-built_in">erase</span>(it1, it1+num_tries);<br></code></pre></td></tr></table></figure></li></ul><h2 id="使用泛型算法">3.5 使用泛型算法</h2><ul><li>以下为四种常用的泛型搜索算法：<ol type="1"><li>find（）用于搜索无序集合中是否存在某值。</li><li>binary_search()用于有序集合的搜索。（效率比find()高）</li><li>count()返回数值相符的元素数目。</li><li>search()比对某个容器内是否存在某个子序列。</li></ol></li><li>binary_search()要求其作用对象必须经过排序（sorted）。</li></ul><h2 id="如何设计一个泛型算法">3.6 如何设计一个泛型算法</h2><h3 id="function-object">Function Object</h3><ul><li>所谓function object是某种class的实例对象，这类class对functioncall运算符做了重载操作，这样一来可使functionobject被当成一般函数来使用。</li><li>functionobject实现了我们原本可能以独立函数加以定义的事物。但何必如此？主要是为了效率。我们可以令call运算符称为inline，从而消除“通过函数指针来调用函数”时付出的额外代价。</li><li><code>&lt;functional&gt;</code>标准库事先定义了一组functionobject，分为算术运算（arithmetic）、关系运算符（relational）和逻辑运算（logical）三大类：<ol type="1"><li>六个算术运算：<code>plus&lt;type&gt;</code>，<code>minus&lt;type&gt;</code>，<code>negate&lt;type&gt;</code>，<code>multiplies&lt;type&gt;</code>，<code>divides&lt;type&gt;</code>，<code>modules&lt;type&gt;</code>。</li><li>六个关系运算：<code>less&lt;type&gt;</code>，<code>less_equal&lt;type&gt;</code>，<code>greater&lt;type&gt;</code>，<code>greater_equal&lt;type&gt;</code>、<code>equal_to&lt;type&gt;</code>，<code>not_equal_to&lt;type&gt;</code>。</li><li>三个逻辑运算，分别对应&amp;&amp;、||、!运算符：<code>logical_and&lt;type&gt;</code>、<code>logical_or&lt;type&gt;</code>、<code>logical_not&lt;type&gt;</code>。</li></ol></li></ul><h3 id="function-object-adapter">Function Object Adapter</h3><ul><li>function object adapter会对functionobject进行修改操作。所谓<strong>binderadapter</strong>（绑定适配器）会将functionobject的参数绑定至特定值，使binary（二元）functionobject转化为unary（一元）function object。</li><li>标准库提供了两个binderadapter：<em>bind1st</em>会将指定值绑定至第一操作数，<em>bind2nd</em>则将指定值绑定至第二操作数。</li><li>另一种adapter是所谓的<strong>negator</strong>，它会对functionobject的真伪值取反。not1可对unary functionobject的真伪值取反，not2可对binary function object的真伪值取反。</li></ul><h2 id="使用map">3.7 使用Map</h2><ul><li>map被定义为一对（pair）数值，其中的key通常是个字符串，扮演索引的角色，另一个数值是value。</li><li>任何一个key值在map内最多只会有一份。如果我们需要储存多份相同的key值，就必须使用multimap。</li></ul><h2 id="使用set">3.8 使用Set</h2><ul><li>Set由一群key组合而成。如果我们想知道某值是否存在于某个集合内，就可以使用set。</li><li>默认情形下，set元素一句其所属类型默认的less-than运算符进行排列。例如，如果给定<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ia[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(ia, ia+<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">set_i</span><span class="hljs-params">(vec.begin(), vec.end())</span></span>;<br></code></pre></td></tr></table></figure> <code>set_i</code>的元素将为{1,3,5,8}。</li><li>如果要为set加入单一元素，可使用单一参数的insert()。</li><li>如果要为set加入某一范围的元素，可使用双参数的insert()。</li></ul><h2 id="如何使用iterator-inserter">3.9 如何使用Iterator Inserter</h2><ul><li>标准库提供了三个所谓的<strong>insertionadapter</strong>，这些adapter让我们得以避免使用容器的assignment运算符：<ol type="1"><li>back_inserter()会以容器的push_back()函数取代assignment运算符。</li><li>inserter()会以容器的insert() 函数取代assignment运算符。</li><li>front_inserter()会以容器的push_front()函数取代assignment运算符。仅适用于list和deque。</li></ol></li><li>欲使用上述三种adapter，必须首先包含iterator头文件。</li><li>这些adapter不能用在array上，因为array不支持元素插入操作。</li></ul><h2 id="使用iostream-iterator">3.10 使用iostream Iterator</h2><ul><li>标准库定义有供输入及输出使用的iostreamiterator类，称为istream_iterator和ostream_iterator，分别支持单一类型的元素读取和写入。使用这两个iteratorclass之前，先得包含iterator头文件。</li><li>如果希望从文件中读取，写入文件中去。只需要将istream_iterator绑定至ifstreamobject，将ostream_iterator绑定至ofstream object即可。</li></ul><h1 id="第4章-基于对象的编程风格">第4章 基于对象的编程风格</h1><ul><li>本章节将带你亲身了解class机制的设计与使用过程。在这个过程中，你会看到如何为自身的应用系统建立起专属的数据类型。</li><li>一般而言，class由两部分组成：一组公开的（public）操作函数和运算符，以及一组私有的（private）实现细节。</li><li>这些操作函数和运算符称为class的memberfunction（成员函数），并代表这个class的公开接口。身为class用户，只能访问公开接口。</li><li>Class的private实现细节可由memberfunction的定义以及与此class相关的任何数据组成。</li><li>Class用户通常不会关心细节的实现。身为一个用户，我们只利用其公开接口来进行编程。这种情形下，只要接口没有更改，即使实现细节重新打造，所有的应用程序代码也不需要变动。</li><li>这一章我们的境界将从class的使用提升至class的设计与实现。这正是C++程序员的主要工作。</li></ul><h2 id="如何实现一个class">4.1 如何实现一个Class</h2><ul><li>Class定义由两部分组成：class的声明，以及紧接着在声明之后的主体。主体部分由一对大括号括住，并以一对分号结尾。主题内的两个关键字public和private，用来标示每个块的“member访问权限”。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// public接口</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// private的实现部分</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li>所有memberfunction必须在class主体内进行声明。如果在class主体内定义，这个memberfunction会自动被视为<strong>inline</strong>函数。</li></ul><h2 id="什么是构造函数和解析函数">4.2 什么是构造函数和解析函数</h2><ul><li><strong>构造函数</strong>（constructor）:编译器在每次classobject被定义出来时使用的初始函数。</li><li>constructor的函数名必须与class名相同。语法规定，constructor不应指定返回类型，亦不用返回任何值。它可以被重载。</li><li>以下代码无法成功定义一个Triangular object： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Triangular <span class="hljs-title">t5</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>因为C++必须兼容C。对C而言，t5之后带有小括号，会使t5被视为函数。 ###Member Initialization List（成员初始化列表）</li><li>Member initializationlist紧接在参数列表最后的冒号后面，是个以逗号分隔的列表。其中，欲赋值给member的数值被放在member名称后面的小括号中；这使它们看起来像是在调用constructor。<em>Memberinitialization list主要用于将参数传给member classobject的constructor</em>。</li><li><strong>析构函数</strong>（destructor）：一旦某个class提供有destructor，当其object结束生命时，便会自动调用destructor处理善后。Destructor主要用来释放在constructor中或对象生命周期中的资源。</li><li>Destructor的名称有严格的规定：class名称再加上'~'前缀。它绝不会有返回值，也没有任何参数。由于其参数列表为空，也不可能被重载。</li><li>Destructor并非绝对必要。事实上，C++编程的最难部分之一，便是了解何时需要定义destructor而何时不需要。### Memberwise Initialization（成员逐一初始化）</li><li>默认情况下，当我们以某个class object作为另一个object的初值，classdata member会被依次复制。此即所谓的Default MemberwiseInitialization（默认成员逐一初始化）。</li><li>当我们设计class时，必须问问自己，在此class上进行“成员逐一初始化”的行为模式是否合适？如果答案是肯定的，我们就不需要另外提供copyconstructor。否则，我们必须另行定义copy constructor。</li></ul><h2 id="何谓mutable可变和const不变">4.3何谓mutable（可变）和const（不变）。</h2><ul><li>class设计者必须在memberfunction身上标注const，以此告诉编译器：这个member function不会更改classobject内容。</li><li>const修饰符必须在函数参数列表之后。</li><li>编译器会检查每个声明为const的memberfunction，看看它们是否真的没有更改class object内容。 ### Mutable DataMember（可变的数据成员）</li><li>关键字mutable可以让我们声明对某一变量的改变不会破坏classobject的常量性。</li></ul><h2 id="什么是this指针">4.4 什么是this指针</h2><ul><li>this指针系在member function内用来指向其调用者（一个对象）。</li></ul><h2 id="静态类成员">4.5 静态类成员</h2><ul><li>static（静态）datamember用来表示唯一的、可共享的member。它可以在同一类的所有对象中被访问。### Static Member Function（静态成员函数）</li><li>member function只有在“不访问任何non-staticmember”的条件下才能够被声明为static，声明方式是在声明之前加上关键字static。</li><li>当我们在class主体外定义memberfunction时，无序重复加上关键字static（这个规则同样适用于static datamember）。</li></ul><h2 id="打造一个iterator-class">4.6 打造一个Iterator Class</h2><ul><li>运算符重载的规则：<ul><li>不可以引入新的运算符。除了<code>..</code>、<code>.*</code>、<code>::</code>、<code>:?</code>四个运算符，其他的运算符皆可被重载。</li><li>运算符的操作数（operand）个数不可改变。</li><li>运算符的优先级（precedence）不可改变。</li><li>运算符函数的参数列表中，必须至少有一个参数为class类型。</li></ul></li><li>后置运算符重载必须提供一个int参数。 ### 嵌套类型（Nested Type）</li><li>一个类可以定义在另一个类的内部，前者称为嵌套类。（CSDN里要比书上讲的清晰的多）<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/Poo_Chai/article/details/91596538">[1]</span></a></sup></li><li>typedef可以为某个类型设定另一个不同的名称。其通用形式为<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> existing_type new_name;<br></code></pre></td></tr></table></figure></li></ul><h2 id="合作关系必须建立在友谊的基础上">4.7合作关系必须建立在友谊的基础上</h2><ul><li>任何class都可以将其它function或class指定为朋友（friend）。而所谓<strong>friend</strong>，具备了让任何non-memberfunction与class member function相同的访问权限，可以访问class的privatemember。</li></ul><h2 id="实现一个copy-assignment-operator">4.8 实现一个copy assignmentoperator</h2><ul><li>只要class设计者明确提供了copy assignmentoperator，它就会被用来取代default memberwise copy行为。</li></ul><h2 id="实现一个function-object">4.9 实现一个function object</h2><ul><li>所谓<strong>function object</strong>乃是一种“提供有functioncall运算符”（<code>()</code>运算符的重载）的class。</li></ul><h2 id="重载iostream运算符">4.10 重载iostream运算符</h2><ul><li>output运算符（<code>&lt;&lt;</code>）的重载。</li><li>input运算符（<code>&gt;&gt;</code>）的重载。</li></ul><h2 id="指针指向class-member-function">4.11 指针，指向Class MemberFunction</h2><ul><li><strong>maximal munch编译规则</strong>：每个符号序列（symbolsequence）总是以“合法符号序列”中最长的哪个解释。</li><li>Pointer to member function和pointer tofunction的一个不同点是，前者必须通过同一类的对象加以调用，而该对象便是此memberfunction内的this指针所指之物。</li></ul><h1 id="第5章-面向对象编程风格">第5章 面向对象编程风格</h1><p>第5章介绍如何扩展class，使多个相关的class形成族系，支持面向对象的class层次体系。</p><h2 id="面向对象编程概念">5.1 面向对象编程概念</h2><ul><li><strong>继承（inheritance）</strong>：使得我们将一群相关的类组织起来，并让我们得以分享其间的共通数据和操作行为。</li><li><strong>多态（polymorphism）</strong>：可以让我们在这些类上进行编程时，可以如同操控单一个体，而非相互独立的类，并赋予我们更多弹性来加入或移除任何特定类。</li><li>在C++中，父类被称为基类（base class），子类被称为派生类（derivedclass）。</li><li>多态（polymorphism）让基类的pointer或reference得以十分透明地（transparently）指向其任何一个派生类的对象。</li><li><strong>静态绑定（staticbinding）</strong>：程序执行之前就已解析出应该调用哪一个函数。</li><li><strong>动态绑定（dynamicbinding）</strong>：“找出实际被调用的是哪一个派生类的目标函数”这一解析操作会延迟至运行时（run-time）才进行。</li></ul><h2 id="漫游面向对象编程思维">5.2 漫游：面向对象编程思维</h2><ul><li>默认情况下，memberfunction的解析（resolution）皆在编译时静态地进行。若要令其在运行时动态进行，我们就得在它的声明前加上关键字virtual。</li><li>当程序定义出一个派生对象，基类和派生类的constructor都会被执行。（当派生对象被销毁，基类和派生类的destructor也都会被执行[<em>但次序颠倒</em>]。）</li></ul><h2 id="不带继承的多态">5.3 不带继承的多态</h2><ul><li>面向对象编程模式消除了这种（不带继承的多态）方式的维护负担，使我们的程序得以精简，更具扩展性。</li></ul><h2 id="定义一个抽象基类">5.4 定义一个抽象基类</h2><ul><li>定义抽象类的第一个步骤就是找出所有子类共通的操作行为。</li><li>设计抽象基类的下一步，便是设法找出哪些操作行为与类型相关（type-dependent）。这些操作行为应该成为整个类继承体系中的虚函数（virtualfunction）。</li><li>设计抽象基类的第三步，便是试着找出每个操作行为的访问层级（accesslevel）。</li><li>每个虚函数，要么得有其定义，要么可设为“纯”虚函数（pure virtualfunction）——如果对于该类而言，这个虚函数并无实质意义的话，将虚函数赋值为0，意为它是一个纯虚函数。</li><li>根据一般规则，凡基类定义有一个（或多个）虚函数，应该将其destructor声明为virtual。</li></ul><h2 id="定义一个派生类">5.5 定义一个派生类</h2><ul><li>派生类名称后紧跟冒号、关键字public，以及基类的名称。</li><li>派生类必须为从基类继承而来的每个纯虚数提供对应的实现。此外，它还必须声明其专属的member。</li><li>一般来说，继承而来的public和protected成员，不论在继承体系中深度如何，都可被视为派生类自身拥有的成员。</li></ul><h2 id="运用继承体系">5.6 运用继承体系</h2><h2 id="基类应该多么抽象">5.7 基类应该多么抽象</h2><ul><li>基类的另一种设计方式：将所有派生类共有的实现内容剥离出来移至基类中，接口仍旧没有变动。</li></ul><h2 id="初始化析构复制">5.8 初始化、析构、复制</h2><ul><li>派生类的constructor，不仅必须为派生类的datamember进行初始化操作，还需要为其基类的data member提供适当的值。</li></ul><h2 id="在派生类中定义一个虚函数">5.9 在派生类中定义一个虚函数</h2><ul><li>当我们定义派生类时，我们必须决定，究竟要将基类中的虚函数覆盖掉，还是原封不动地加以继承。<ul><li>如果我们继承了纯虚函数（pure virtualfunction），那么这个派生类也会被视为抽象类，也就无法为它定义任何对象。</li><li>如果我们决定覆盖基类所提供的虚函数，那么派生类提供新的定义，其函数原型必须完全符合基类所声明的函数原型，包括：参数列表、返回类型、常量性（const-ness）。</li></ul></li><li>“返回类型必须完全吻合”这一规则有个例外——当基类的虚函数返回某个基类形式（通常是pointer或reference时），派生类的同名函数可以返回该基类所派生出来的类型。### 虚函数的静态解析（Static Resolution）</li><li>有两种情况，虚函数机制不会出现预期行为：<ol type="1"><li>基类的constructor和destructor内；</li><li>当我们使用的是基类对象，而非基类对象的pointer或reference时。</li></ol></li><li>为了能够“在单一对象中展现多种类型”，多态（polymorphism）需要一层间接性。在C++中，唯有用基类的pointer或reference才能够支持面向对象的编程概念。</li></ul><h2 id="运行时的类型鉴定机制">5.10 运行时的类型鉴定机制</h2><ul><li>typeid运算符是所谓运行时类型鉴定机制（Run-Time Type Identification，RTTI）的一部分，由程序语言支持。它让我们得以查询多态化的classpointer或class reference，获得其所指对象的实际类型。</li><li>使用typeid运算符前，必须先包含头文件<code>&lt;typeinfo&gt;</code>。</li><li>typeid运算符会返回一个type_info对象，其中储存着与类型相关的种种信息。</li><li>static_cast可以进行强制转换，但有潜在威胁，因为编译器无法确认我们所进行的转换操作是否完全正确。</li><li>dynamic_cast也是一个RTTI运算符，它会进行运行时检验操作，检验强转对象是否为目标值。</li></ul><h1 id="第6章-以template进行编程">第6章 以template进行编程</h1><ul><li>第6章的重头戏是classtemplate，那是建立class时的一种先行描述，让我们得以将class用到的一个（或多个）数据类型或数据值，抽离并参数化。以vector为例，可能需要将其元素的类型加以参数化，而buffer的设计不仅得将元素类型参数化，还得将其缓冲区容量参数化。本章的行进路线围绕在二分树（binarytree）class template的实现上。</li><li>在数据结构中，所谓树（tree）乃是由节点（node，或谓vertice）以及连接不同节点的链接（link）组成。所谓二叉树，维护着每个节点与下层另两个节点间的两条链接，一般将此下层二节点称为左子节点（leftchild）和右子节点（rightchild）。最上层第一个节点称为根节点（root）。无论是左子节点或右子节点，都可能扮演另一颗“子树（subtree）”的根节点。一个节点如果不再有任何子节点，便称为叶节点（leaf）。</li></ul><h2 id="被参数化的类型">6.1 被参数化的类型</h2><ul><li>template机制能帮助我们将类定义中“与类型相关（type-dependent）”和“独立于类型之外”的两部分分离开。</li></ul><h2 id="class-template的定义">6.2 Class Template的定义</h2><ul><li>在classscope运算符出现之后，其后所有东西都被视为位于class定义范围内。</li></ul><h2 id="template类型参数的处理">6.3 Template类型参数的处理</h2><ul><li>建议将所有的template类型参数视为“class类型”来处理，不要选择在constructor内初始化。这意味着我们会把它声明为一个constreference，而非以by value的方式传递。</li></ul><h2 id="实现一个class-template">6.4 实现一个Class Template</h2><ul><li>new表达式可以分解为两个操作：<ol type="1"><li>向程序的空闲空间（freestore）请求内存。如果分配到足够的空间，就分配一个指针，指向新对象。</li><li>如果第一步成功，并且外界指定了一个初值，这个新对象便会以最适当的方式被初始化。</li></ol></li><li>二叉树中移除某值的一般算法是，以节点的右子节点取代节点本身，然后搬移左子节点，使它成为右子节点的左子树的叶节点。</li><li>声明一个reference topointer，我们不但可以改变pointer本身，也可以改变由此pointer指向的对象。</li></ul><h2 id="一个以function-template完成的output运算符">6.5 一个以FunctionTemplate完成的Output运算符</h2><h2 id="常量表达式与默认参数值">6.6 常量表达式与默认参数值</h2><ul><li>Template参数并不是非得某种类型（type）不可。我们也可以用常量表达式（constantexpression）作为template参数。</li><li>全局作用域（globalscope）内的函数及对象，其地址也是一种常量表达式，因此也可以被拿来表达这一形式的参数。</li></ul><h2 id="以template参数作为一种设计策略">6.7以Template参数作为一种设计策略</h2><ul><li>class template无法基于参数列表的不同而重载。</li></ul><h2 id="member-template-function">6.8 Member Template Function</h2><ul><li>Non-template class或class template内都可定义member templatefunction。</li></ul><h1 id="第7章-异常处理">第7章 异常处理</h1><p>第7章介绍了如何使用C++的异常处理机制（exception handlingfacility），并示范如何将它融入标准库所定义的异常体系中。</p><h2 id="抛出异常">7.1 抛出异常</h2><ul><li>异常处理机制有两个主要成分：异常的鉴定与发出，以及异常的处理方式。</li><li>异常出现之后，正常程序的执行便被暂停（suspended）。与此同时，异常处理机制开始搜索程序中有能力处理这一异常的地点。异常被处理完毕之后，程序的执行便会继续（resume），从异常处理点接着执行下去。</li><li>所谓异常（<strong>exception</strong>）是某种对象。大部分时候，被抛出的异常都属于特定的异常类（也许形成一个继承体系）。我们只是令它得以储存某些必要数据，用以表示异常的性质，以便我们得以在不同程序的不同调用点上相互传递这些性质。</li></ul><h2 id="捕获异常">7.2 捕获异常</h2><ul><li>我们可以利用单条或一连串的catch子句来捕获（catch）被抛出的异常对象。catch子句由三部分组成：关键字catch、小括号内的一个类型或对象、大括号内的一组语句（用以处理异常）。</li><li>异常对象的类型会被拿来逐一地和每个catch子句比对。如果类型符合，那么该catch子句的内容便会被执行。</li><li>有时候我们可能无法完成异常的完整处理。在记录信息之外，我们或许需要重新抛出（rethrow）异常，以寻求其它catch子句的协助，做进一步的处理。重新抛出时，只需要写下关键字throw即可。它只能出现于catch子句中。它会将捕获的异常对象再一次抛出，并由另一个类型吻合的catch子句接受处理。</li><li>如果我们想要捕获任何类型的异常，可以使用一网打尽（catch-all）的方式。只需在异常声明部分指定省略号（…）即可，像这样：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//捕获任何类型的异常</span><br><span class="hljs-built_in">catch</span>( ... )<br>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="提炼异常">7.3 提炼异常</h2><ul><li>catch子句应该和try块相应而生。try块是以关键字try作为开始，然后是大括号内的一连串程序语句。catch子句放在try块的末尾，这表示如果try块内有任何异常发生，便由接下来的catch子句加以处理。</li><li>如果“函数调用链”不断地被解开，一直回到了main（）还是找不到合适的catch子句。C++规定，每个异常都应该被处理。因此，标准库提供的terminate()便被调用——其默认行为时是中断整个程序的执行。</li></ul><h2 id="局部资源管理">7.4 局部资源管理</h2><ul><li><strong>Resource acquisitioninitialization（在初始化阶段即进行资源请求）</strong>：对对象而言，初始化操作发生在constructor中，资源的请求亦发生在constructor内。资源的释放则应在destructor内完成。在异常处理机制终结某个函数之前，C++保证，函数中的所有局部对象的destructor都会被调用。</li><li>auto_ptr是标准库提供的classtemplate，它会自动删除通过new表达式分配的对象。使用它前，必须包含相应的memory头文件：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul><h2 id="标准异常">7.5 标准异常</h2><ul><li>如果new表达式无法从程序的空闲空间（freestore）分配到足够的内存，它会抛出bad_alloc异常对象。</li><li>标准库定义了一套异常类体系（exception classhierarchy），其根部是名为exception的抽象基类。</li><li>bad_alloc派生自exception基类。<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>https://blog.csdn.net/Poo_Chai/article/details/91596538<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section></li></ul>]]></content>
    
    
    <categories>
      
      <category>Essential C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown All in One常用操作汇总（for Windows）</title>
    <link href="/2023/09/22/Markdown_All_in_One%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/"/>
    <url>/2023/09/22/Markdown_All_in_One%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#键盘快捷键">键盘快捷键</a></li><li><a href="#创建目录">创建目录</a></li><li><a href="#列编辑">列编辑</a></li><li><a href="#github-flavored-markdown">Github FlavoredMarkdown</a></li><li><a href="#其它">其它</a></li></ul><h1 id="键盘快捷键">键盘快捷键</h1><ol type="1"><li><p>加粗（Bold）<code>Ctrl + B</code> <img src="/2023/09/22/Markdown_All_in_One%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/toggle-bold-1.gif" alt="Alt text"></p></li><li><p>斜体（Italic）<code>Ctrl + I</code></p></li><li><p>任务列表快速选择 <code>Alt + C</code> <img src="/2023/09/22/Markdown_All_in_One%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/check-task-list.gif"></p></li><li><p>删除线 <code>Alt + S</code></p></li><li><p>标题（升级）<code>Ctrl + Shift + ]</code></p></li><li><p>标题（降级）<code>Ctrl + Shift + [</code></p></li><li><p>数学环境 <code>Ctrl + M</code></p></li><li><p>预览 <code>Ctrl + Shift + V</code></p></li><li><p>侧边预览 <code>Ctrl + K V</code></p></li></ol><h1 id="创建目录">创建目录</h1><ul><li>在VSCode命令面板中运行命令"Create Table ofContents"来插入一个新目录。(<code>Ctrl + T 输入"&gt;Create Table of Contents"</code>)</li><li>默认情况下，Table ofContent（TOC）会自动更新。若要禁用，请更改<code>toc.updateOnSave</code>选项。</li><li>轻松添加/更新/删除章节编号 <img src="/2023/09/22/Markdown_All_in_One%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/section-numbers.gif"></li></ul><h1 id="列编辑">列编辑</h1><ol type="1"><li><img src="/2023/09/22/Markdown_All_in_One%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/on-enter-key.gif"></li><li><img src="/2023/09/22/Markdown_All_in_One%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/tab-backspace.gif"></li><li><img src="/2023/09/22/Markdown_All_in_One%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/fix-marker.gif"></li></ol><h1 id="github-flavored-markdown">Github Flavored Markdown</h1><ul><li>表格式化 <img src="/2023/09/22/Markdown_All_in_One%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/table-formatter.gif"></li></ul><h1 id="其它">其它</h1><ul><li>在选定的文本上粘贴链接 <img src="/2023/09/22/Markdown_All_in_One%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/paste-link.gif"></li></ul>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode + Hexo实现本地图片上传</title>
    <link href="/2023/09/21/VSCode-Hexo%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/"/>
    <url>/2023/09/21/VSCode-Hexo%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>在写第二篇博文（Markdown学习笔记）的时候遇到的一个问题，本地存储的图片部署后无法显示到网页上。为了解决这个问题需要做两处修改。</p><h1 id="一修改vscode默认图片存储位置1">一、修改VSCode默认图片存储位置<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.cnblogs.com/xbotter/p/17528063.html">[1]</span></a></sup></h1><p>首先 <code>Ctrl</code> + <code>,</code>打开VSCode的设置首选项。搜索“markdownimage”，添加一个项-值对为：<code>**/*.md</code>,<code>$&#123;documentBaseName&#125;/$&#123;fileName&#125;</code>。保存并退出。</p><figure><img src="/2023/09/21/VSCode-Hexo%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/image.png" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><p>这样后续粘贴进VS文本框的图片将会存放在.md文件同级目录下的同名文件夹中，方便进行文件管理。</p><figure><img src="/2023/09/21/VSCode-Hexo%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/image-1.png" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><h1 id="二安装hexo-asset-image插件2">二、安装hexo-asset-image插件<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.jianshu.com/p/db02d775aed0">[2]</span></a></sup></h1><p>使用命令 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/CodeFalling/</span>hexo-asset-image --save<br></code></pre></td></tr></table></figure> 安装hexo-asset-image插件</p><p><strong>Tips:</strong> 安装失败可以尝试使用cnpm安装。</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>https://www.cnblogs.com/xbotter/p/17528063.html<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>https://www.jianshu.com/p/db02d775aed0<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown学习笔记</title>
    <link href="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>为了今后的博客写作，有必要系统的学习Markdown。此笔记是<a href="https://markdown.com.cn/">Markdown官方教程</a>的学习记录，目的是加深对Markdown中概念的记忆，在实践中增强对Markdown语法的熟练度。</p><h1 id="一入门基础">一、入门基础</h1><h2 id="markdown是什么">Markdown是什么？</h2><p>Markdown 是一种轻量级的标记语言，可用于在纯文本文档中添加格式化元素。## 为什么要使用Markdown？ * Markdown无处不在。StackOverflow、CSDN、掘金、简书、GitBook、有道云笔记、V2EX、光谷社区等。主流的代码托管平台，如GitHub、GitLab、BitBucket、Coding、Gitee 等等，都支持 Markdown语法，很多开源项目的 README、开发文档、帮助文档、Wiki 等都用 Markdown写作。 * Markdown 是纯文本可移植的。几乎可以使用任何应用程序打开包含Markdown 格式的文本文件。如果你不喜欢当前使用的 Markdown应用程序了，则可以将 Markdown 文件导入另一个 Markdown 应用程序中。这与Microsoft Word 等文字处理应用程序形成了鲜明的对比，Microsoft Word将你的内容锁定在专有文件格式中。 * Markdown是独立于平台的。你可以在运行任何操作系统的任何设备上创建 Markdown格式的文本。 * Markdown能适应未来的变化。即使你正在使用的应用程序将来会在某个时候不能使用了，你仍然可以使用文本编辑器读取Markdown格式的文本。当涉及需要无限期保存的书籍、大学论文和其他里程碑式的文件时，这是一个重要的考虑因素。## 工欲善其事，必先利其器 我选择 VSCode + Markdown All in One。 ##Markdown的工作原理Markdown应用程序都是将Markdown格式的文本转换为HTML，以便可以在Web浏览器中显示。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image.png" alt="Alt text"><br>这是一个四步的过程： 1. 使用文本编辑器或 Markdown 专用的应用程序创建Markdown 文件。该文件应带有 .md 或 .markdown 扩展名。 2. 在 Markdown应用程序中打开 Markdown 文件。 3. 使用 Markdown 应用程序将 Markdown文件转换为 HTML 文档。 4. 在 web 浏览器中查看 HTML 文件，或使用 Markdown应用程序将其转换为其他文件格式，例如 PDF。 ## Markdown有什么用 Markdown是做笔记、为网站创建内容以及生成可打印文档的快速、简便的方法。有如下具体的应用领域：网站、文件资料、笔记、书籍、演示文稿、邮件、文档。## Markdown方言每个Markdown应用程序都实现了稍有不同的Markdown语法。Markdown的这些变体通常被成为<em>flavors（方言）</em></p><h1 id="二基本语法">二、基本语法</h1><h2 id="markdown标题语法">Markdown标题语法</h2><p>要创建标题，请在单词或短语前面添加井号 (#) 。#的数量代表了标题的级别。例如，添加三个 # 表示创建一个三级标题(例如：###My Header)。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-1.png" alt="Alt text"><br>### 可选语法 还可以在文本下方添加任意数量的 == 号来标识一级标题，或者 --号来标识二级标题。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-2.png" alt="Alt text"><br>### 最佳实践 不同的Markdown应用程序处理 <code>#</code>和标题之间的空格方式并不一致。为了兼容考虑，请用一个空格在<code>#</code> 和标题之间进行分隔。<br><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-3.png" alt="Alt text"> ## Markdown 段落语法要创建段落，请使用空白行将一行或多行文本进行分隔。 <img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-4.png" alt="Alt text"> ### 段落（paragraph）用法的最佳实践不要用空格（spaces）或制表符（tabs）缩进段落。 <img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-5.png" alt="Alt text"> ## Markdown换行语法在一行的末尾添加两个或多个空格，然后按回车键即可创建一个换行。 <img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-6.png" alt="Alt text"> ### 换行（Line Break）用法的最佳实践 几乎每个 Markdown应用程序都支持两个或多个空格进行换行，称为 <strong>结尾空格（trailingwhitespace)</strong>的方式，但这是有争议的，因为很难在编辑器中直接看到空格，并且很多人在每个句子后面都会有意或无意地添加两个空格。由于这个原因，你可能要使用除结尾空格以外的其它方式来换行。幸运的是，几乎每个Markdown 应用程序都支持另一种换行方式：HTML 的 <code>&lt;br&gt;</code>标签。</p><p>为了兼容性，请在行尾添加“结尾空格”或 HTML 的 <code>&lt;br&gt;</code>标签来实现换行。</p><p>还有两种其他方式我并不推荐使用。CommonMark和其它几种轻量级标记语言支持在行尾添加反斜杠 (\)的方式实现换行，但是并非所有 Markdown应用程序都支持此种方式，因此从兼容性的角度来看，不推荐使用。并且至少有两种轻量级标记语言支持无须在行尾添加任何内容，只须键入回车键（return）即可实现换行。<img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-7.png" alt="Alt text"> ## Markdown强调语法通过将文本设置为<strong>粗体</strong>或<em>斜体</em>来强调其重要性。 ###粗体（Bold）要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。<img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-8.png" alt="Alt text"> #### 粗体（Bold）用法最佳实践 为考虑 Markdown应用程序的兼容性问题，推荐只使用星号（asterisks）进行加粗强调。 <img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-9.png" alt="Alt text"> ### 斜体（Italic）要用斜体显示文本，请在单词或短语前后添加一个星号（asterisks）或下划线（underscores）。<img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-10.png" alt="Alt text"> #### 斜体（Italic）用法的最佳实践<br>为考虑 Markdown应用程序的兼容性问题，推荐只使用星号（asterisks）进行斜体强调。 ###粗体（Bold）和斜体（Italic）要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。<img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-11.png" alt="Alt text"> #### 粗体（Bold）和斜体（Italic）用法的最佳实践 为考虑Markdown 应用程序的兼容性问题，推荐只使用星号进行斜体和斜体强调。 ##Markdown 引用语法要创建块引用，请在段落前添加一个<code>&gt;</code>符号。 <figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Dorothy</span> followed her through many <span class="hljs-keyword">of</span> the beautiful rooms <span class="hljs-keyword">in</span> her castle.</span><br></code></pre></td></tr></table></figure>渲染效果如下： &gt; Dorothy followed her through many of the beautifulrooms in her castle. ### 多个段落的块引用块引用可以包含多个段落。为段落之间的空白行添加一个<code>&gt;</code>符号。<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Dorothy</span> followed her through many <span class="hljs-keyword">of</span> the beautiful rooms <span class="hljs-keyword">in</span> her castle.</span><br><span class="hljs-meta prompt_">&gt;</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">The</span> <span class="hljs-title class_">Witch</span> bade her clean the pots and kettles and sweep the floor and keep the fire fed <span class="hljs-keyword">with</span> wood.</span><br></code></pre></td></tr></table></figure> 渲染效果如下： &gt; Dorothy followed her through many ofthe beautiful rooms in her castle. &gt; &gt; The Witch bade her cleanthe pots and kettles and sweep the floor and keep the fire fed withwood. ### 嵌套块引用块引用可以嵌套。在要嵌套的段落前添加一个<code>&gt;&gt;</code>符号。<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">&gt; Dorothy followed her through many of the <span class="hljs-keyword">beautiful </span>rooms in her castle.<br>&gt;<br>&gt;&gt; The Witch <span class="hljs-keyword">bade </span>her clean the pots <span class="hljs-keyword">and </span>kettles <span class="hljs-keyword">and </span><span class="hljs-keyword">sweep </span>the floor <span class="hljs-keyword">and </span>keep the fire fed with wood.<br></code></pre></td></tr></table></figure> 渲染效果如下： &gt; Dorothy followed her through many ofthe beautiful rooms in her castle. &gt; &gt;&gt; The Witch bade herclean the pots and kettles and sweep the floor and keep the fire fedwith wood. ### 带有其它元素的块引用 块引用可以包含其他 Markdown格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">#### <span class="hljs-title class_">The</span> quarterly results look great!</span><br><span class="hljs-meta prompt_">&gt;</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">- <span class="hljs-title class_">Revenue</span> was off the chart.</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">- <span class="hljs-title class_">Profits</span> were higher than ever.</span><br><span class="hljs-meta prompt_">&gt;</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"> *<span class="hljs-title class_">Everything</span>* is going according to **plan**.</span><br></code></pre></td></tr></table></figure> 渲染效果如下： &gt; #### The quarterly results look great!&gt; &gt; - Revenue was off the chart. &gt; - Profits were higher thanever. &gt; &gt; <em>Everything</em> is going according to<strong>plan</strong>. ## Markdown 列表语法可以将多个条目组织成有序或无序列表。 ### 有序列表要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字1起始。<img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-12.png" alt="Alt text"> #### 有序列表最佳实践 一些 Markdown应用程允许使用圆括号（<code>)</code>）作为分隔符（例：<code>1) First item</code>），但并非所有Markdown应用程序都支持它，所以从兼容性的角度考虑推荐只使用英文句点（<code>.</code>）作为分隔符。<img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-13.png" alt="Alt text"> ### 无序列表要创建无序列表，请在每个列表项前面添加破折号（-）、星号（<em>）或加号（+）。缩进（使用制表符Tab）1个或多个列表项可创建嵌套列表。<img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-14.png" alt="Alt text"> #### 无序列表最佳实践 Markdown应用程序不支持处理同一列表中存在多个分隔符的情况。为了兼容性的考量，请不要在同意列表中混合使用无序列表分隔符——选中一个并坚持使用它。<img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-15.png" alt="Alt text"> ### 在列表中嵌套其他元素要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符，如下例所示：#### 段落 <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">*   This <span class="hljs-keyword">is</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> <span class="hljs-built_in">list</span> <span class="hljs-built_in">item</span>.<br>*   Here&#x27;s <span class="hljs-keyword">the</span> <span class="hljs-keyword">second</span> <span class="hljs-built_in">list</span> <span class="hljs-built_in">item</span>.<br><br>    I need <span class="hljs-keyword">to</span> add another <span class="hljs-built_in">paragraph</span> <span class="hljs-keyword">below</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">second</span> <span class="hljs-built_in">list</span> <span class="hljs-built_in">item</span>.<br><br>*   And here&#x27;s <span class="hljs-keyword">the</span> <span class="hljs-keyword">third</span> <span class="hljs-built_in">list</span> <span class="hljs-built_in">item</span>.<br></code></pre></td></tr></table></figure> 渲染效果如下： </em> This is the first listitem. * Here's the second list item.</p><pre><code class="hljs">I need to add another paragraph below the second list item.</code></pre><ul><li><p>And here's the third list item. #### 引用块 <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">*   This <span class="hljs-keyword">is</span> the first list item.<br>*   Her<span class="hljs-string">e&#x27;s the second list item.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &gt; A blockquote would look great below the second list item.</span><br><span class="hljs-string"></span><br><span class="hljs-string">*   And here&#x27;</span>s the third list item.<br></code></pre></td></tr></table></figure>渲染效果如下：</p></li><li><p>This is the first list item.</p></li><li><p>Here's the second list item.</p><blockquote><p>A blockquote would look great below the second list item.</p></blockquote></li><li><p>And here's the third list item. #### 代码块代码块通常采用四个空格或一个制表符缩进。当它们被放在列表中时，请将它们缩进<em>八个空格或两个制表符</em>。<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span>.  Open the <span class="hljs-keyword">file</span>.<br><span class="hljs-number">2</span>.  Find the following code block <span class="hljs-keyword">on</span> <span class="hljs-built_in">line</span> <span class="hljs-number">21</span>:<br><br>        <span class="hljs-symbol">&lt;html&gt;</span><br>          <span class="hljs-symbol">&lt;head&gt;</span><br>            <span class="hljs-symbol">&lt;title&gt;</span>Test&lt;/title&gt;<br>          &lt;/head&gt;<br><br><span class="hljs-number">3</span>.  Update the title <span class="hljs-keyword">to</span> <span class="hljs-keyword">match</span> the name of your website.<br></code></pre></td></tr></table></figure> 渲染效果如下：</p></li></ul><ol type="1"><li><p>Open the file.</p></li><li><p>Find the following code block on line 21:</p><pre><code class="hljs">&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Test&lt;/title&gt;  &lt;/head&gt;</code></pre></li><li><p>Update the title to match the name of your website. #### 图片<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-number">1.</span>  Open the <span class="hljs-keyword">file</span> containing the Linux mascot.<br><span class="hljs-number">2.</span>  Marvel at its beauty.<br><br>    ![Tux, the Linux mascot](MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/<span class="hljs-keyword">image</span><span class="hljs-number">-16.</span>png)<br><br><span class="hljs-number">3.</span>  Close the <span class="hljs-keyword">file</span>.<br></code></pre></td></tr></table></figure> 渲染效果如下：</p></li><li><p>Open the file containing the Linux mascot.</p></li><li><p>Marvel at its beauty.</p><figure><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-16.png" alt="Tux, the Linux mascot"><figcaption aria-hidden="true">Tux, the Linux mascot</figcaption></figure></li><li><p>Close the file. #### 列表你可以在有序列表中嵌套无序列表，反之亦然。 <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1.</span> First <span class="hljs-built_in">item</span><br><span class="hljs-number">2.</span> Second <span class="hljs-built_in">item</span><br><span class="hljs-number">3.</span> Third <span class="hljs-built_in">item</span><br>    - Indented <span class="hljs-built_in">item</span><br>    - Indented <span class="hljs-built_in">item</span><br><span class="hljs-number">4.</span> Fourth <span class="hljs-built_in">item</span><br></code></pre></td></tr></table></figure>渲染效果如下：</p></li><li><p>First item</p></li><li><p>Second item</p></li><li><p>Third item</p><ul><li>Indented item</li><li>Indented item</li></ul></li><li><p>Fourth item ## Markdown代码语法要将单词或短语表示为代码，请将其包裹在反引号（<code>`</code>）中。 <img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-17.png" alt="Alt text"> ### 转义反引号如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号（<code>``</code>）中。<img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-18.png" alt="Alt text"></p></li></ol><h3 id="代码块">代码块</h3><p>要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> ## Markdown 分隔线语法要创建分隔线，请在单独一行上使用三个或多个星号（<code>***</code>）、破折号（<code>---</code>）或下划线（<code>___</code>），并且不能包含其他内容。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">***</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">_________________</span><br></code></pre></td></tr></table></figure> 以上三个分隔线的渲染效果看起来都一样。 ###分隔线（Horizontal Rule）用法最佳实践为了兼容性，请在分隔线的前后均添加空白行。 <img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-19.png" alt="Alt text"> ## Markdown 链接语法链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。超链接Markdown语法代码：<code>[超链接显示名](超链接地址 "超链接title")</code>对应的HTML代码：<code>&lt;a href="超链接地址" title="超链接title"&gt;超链接显示名&lt;/a&gt;</code><code>这是一个链接 [Markdown语法](https://markdown.com.cn)。</code>渲染效果如下： 这是一个链接 <a href="https://markdown.com.cn">Markdown语法</a>。 ### 给链接增加Title链接title是当鼠标悬停在链接上时会出现的文字，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。<code>这是一个链接 [Markdown语法](https://markdown.com.cn "最好的markdown教程")。</code>渲染效果如下： 这是一个链接 <a href="https://markdown.com.cn" title="最好的markdown教程">Markdown语法</a>。 ### 网址和Email地址使用尖括号可以很方便地把URL或者Email地址变成可点击的链接。<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">&lt;https://markdown.<span class="hljs-keyword">com</span>.<span class="hljs-keyword">cn</span>&gt;<br>&lt;<span class="hljs-number">1069667084</span>@qq.<span class="hljs-keyword">com</span>&gt;<br></code></pre></td></tr></table></figure> 渲染效果如下： <a href="https://markdown.com.cn" class="uri">https://markdown.com.cn</a> <a href="mailto:1069667084@qq.com" class="email">1069667084@qq.com</a> ###带格式化的链接 <strong><em><a href="https://markdown.com.cn" title="最好的markdown教程">强调</a></em></strong>链接，在链接语法前后增加星号。要将链接表示为代码，请在方括号中添加反引号。<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">I love supporting the <span class="hljs-strong">**[<span class="hljs-string">EFF</span>](<span class="hljs-link">https://eff.org</span>)**</span>.<br>This is the <span class="hljs-emphasis">*[<span class="hljs-string">Markdown Guide</span>](<span class="hljs-link">https://www.markdownguide.org</span>)*</span>.<br>See the section on [<span class="hljs-string">`code`</span>](<span class="hljs-link">#code</span>).<br></code></pre></td></tr></table></figure> 渲染效果如下： I love supporting the <strong><a href="https://eff.org">EFF</a></strong>. This is the <em><a href="https://www.markdownguide.org">Markdown Guide</a></em>. See thesection on <a href="#code"><code>code</code></a>. ### 引用类型链接引用样式链接是一种特殊的链接，它使URL在Markdown中更易于显示和阅读。参考样式链接分为两部分：与文本保持内联的部分以及存储在文件中其他位置的部分，以使文本易于阅读。#### 链接的第一部分格式引用类型的链接的第一部分使用两组括号进行格式设置。第一组方括号包围应显示为链接的文本。第二组括号显示了一个标签，该标签用于指向您存储在文档其他位置的链接。</p><p>尽管不是必需的，可以在第一组和第二组括号之间包含一个空格。第二组括号中的标签不区分大小写，可以包含字母，数字，空格或标点符号。</p><p>以下示例格式对于链接的第一部分效果相同：</p><ul><li><code>[hobbit-hole][1]</code></li><li><code>[hobbit-hole] [1]</code></li></ul><h4 id="链接的第二部分格式">链接的第二部分格式</h4><p>引用类型链接的第二部分使用以下属性设置格式：</p><ol type="1"><li>放在括号中的标签，其后紧跟一个冒号和至少一个空格（例如<code>[label]:</code>）。</li><li>链接的URL，可以选择将其括在尖括号中。</li><li>链接的可选标题，可以将其括在双引号，单引号或括号中。</li></ol><p>以下示例格式对于链接的第二部分效果相同：</p><ul><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle</code></li><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle "Hobbit lifestyles"</code></li><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle 'Hobbit lifestyles'</code></li><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle (Hobbit lifestyles)</code></li><li><code>[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; "Hobbit lifestyles"</code></li><li><code>[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; 'Hobbit lifestyles'</code></li><li><code>[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; (Hobbit lifestyles)</code></li></ul><p>可以将链接的第二部分放在Markdown文档中的任何位置。有些人将它们放在出现的段落之后，有些人则将它们放在文档的末尾（例如尾注和脚注）。### 链接最佳实践不同的Markdown应用程序处理URL中间的空格方式不一样。为了兼容性，请尽量使用<strong><em>%20</em></strong> 代替空格。 <img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20.png" alt="Alt text"> ## Markdown 图片语法要添加图像，请使用感叹号（<code>!</code>），然后再方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。</p><p>插入图片Markdown语法代码：<code>![图片alt](图片链接 "图片title")</code>。</p><p>对应的HTML代码：<code>&lt;img src="图片链接" alt="图片alt" title="图片title"&gt;</code></p><p><code>![这是图片](MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-21.png "Magic Gardens")</code></p><p>渲染效果如下： <img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-21.png" title="Magic Gardens" alt="这是图片"> ### 链接图片给图片增加链接，请将图像的Markdown括在方括号中，然后将链接添加在圆括号中。</p><p><code>[![沙漠中的岩石图片](MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-22.png "Shiprock")](https://markdown.com.cn)</code></p><p>渲染效果如下：</p><p><a href="https://markdown.com.cn"><img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-22.png" title="Shiprock" alt="沙漠中的岩石图片"></a> ## Markdown 转义字符语法要显示原本用于格式化Markdown文档的字符，请在字符前面添加反斜杠字符<code>\</code>。</p><p><code>\* Without the backslash, this would be a bullet in an unordered list.</code></p><p>渲染效果如下：</p><p>* Without the backslash, this would be a bullet in an unorderedlist.</p><h3 id="可做转义的字符">可做转义的字符</h3><p>以下列出的字符都可以通过使用反斜杠字符从而达到转义的目的。 <img src="/2023/09/21/MarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-23.png" alt="Alt text"> ### 特殊字符自动转义在HTML文件中，有两个字符需要特殊处理：<code>&lt;</code>和<code>&amp;</code>。<code>&lt;</code>符号用于起始标签，<code>&amp;</code>符号用于标记HTML实体，如果你只是想要使用这些符号，你必须使用实体的形式，像是<code>&amp;lt;</code>和<code>&amp;amp;</code>。</p><p><em>注：lt为less than的缩写，amp为ampersand的缩写</em></p><p><code>&amp;</code>符号其实很容易让写作网页文件的人感到困扰，如果你要打「AT&amp;T」，你必须要写成「<code>AT&amp;amp;T</code>」，还得转换网址内的<code>&amp;</code>符号，如果你要链接到：<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//im</span>ages.google.com/images?num=<span class="hljs-number">30</span>&amp;q=larry+bird<br></code></pre></td></tr></table></figure> 你必须要把网址转成： <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//im</span>ages.google.com/images?num=<span class="hljs-number">30</span>&amp;amp;q=larry+bird<br></code></pre></td></tr></table></figure>才能放到链接标签的<code>href</code>属性里。不用说也知道这很容易忘记，这也可能是HTML标准检查所检查到的错误中，数量最多的。</p><p>Markdown允许你直接使用这些符号，它帮你自动转义字符。如果你使用<code>&amp;</code>符号作为HTML实体的一部分，那么它不会被转换，而在其它情况下，它则会被转换成<code>&amp;amp;</code>。所以你如果要在文件中插入一个著作权符号，你可以这样写：<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">&amp;copy;</span><br></code></pre></td></tr></table></figure> Markdown将不会对这段文字做修改，但是如果你这样写：<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">AT<span class="hljs-meta">&amp;T</span><br></code></pre></td></tr></table></figure> Markdown就会将它转为： <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">AT</span>&amp;amp<span class="hljs-comment">;T</span><br></code></pre></td></tr></table></figure>类似的情况也会发生在<code>&lt;</code>符号上，因为Markdown支持行内HTML，如果你使用<code>&lt;</code>符号作为HTML标签的的分隔符，那Markdown也不会对它做任何转换，但是如果你是写：<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span>&lt; <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure> Markdown将会把它转换为： <figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span>&amp;lt; <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>需要特别注意的是，在Markdown的块级元素和内联元素中，<code>&lt;</code>和<code>&amp;</code>两个符号都会被自动转换成HTML实体，这项特性让你可以很容易地用Markdown写HTML。（在HTML语法中，你要手动把所有的<code>&lt;</code>和<code>&amp;</code>都转换为HTML实体。）## Markdown内嵌HTML标签对于Markdown涵盖范围之外的标签，都可以直接在文件里面用HTML本身。如需使用HTML，不需要额外标注这是HTML或是Markdown，只需HTML标签添加到Markdown文本中即可。### 行级内联标签 HTML的行级内联标签如<code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code>不受限制，可以在Markdown的段落、列表或是标题里任意使用。依照个人习惯，甚至可以不用Markdown格式，而采用HTML标签来格式化。例如：如果比较喜欢HTML 的 <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code>标签，可以直接使用这些标签，而不用Markdown提供的链接或是图片语法。当你需要更改元素的属性时（例如为文本指定颜色或更改图像的宽度），使用HTML 标签更方便些。</p><p>HTML 行级內联标签和区块标签不同，在內联标签的范围内，Markdown的语法是可以解析的。 <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">This **<span class="hljs-built_in">word</span>** <span class="hljs-keyword">is</span> bold. This &lt;em&gt;<span class="hljs-built_in">word</span>&lt;/em&gt; <span class="hljs-keyword">is</span> italic.<br></code></pre></td></tr></table></figure> 渲染效果如下：</p><p>This <strong>word</strong> is bold. This <em>word</em> is italic. ###区块标签 区块元素──比如<code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code>等标签，必须在前后加上空行，以便于内容区分。而且这些元素的开始与结尾标签，不可以用tab或是空白来缩进。Markdown会自动识别这区块元素，避免在区块标签前后加上没有必要的<code>&lt;p&gt;</code> 标签。 <figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xquery">This <span class="hljs-literal">is</span> a regular paragraph.<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><br><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">        </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Foo<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><br>This <span class="hljs-literal">is</span> another regular paragraph.<br></code></pre></td></tr></table></figure>请注意，Markdown语法在HTML区块标签中将不会被进行处理。例如，你无法在HTML区块中使用Markdown形式的<code>*强调*</code>。### HTML用法最佳实践出于安全原因，并非所有Markdown应用程序都支持在Markdown文档中添加HTML。如有疑问，请查看相应Markdown应用程序手册。某些应用程序只支持HTML标签的子集。</p><p>对于HTML的块级元素<code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code>，请在其前后使用空行（blanklines）与其它内容进行分隔。尽量不要使用制表符（tabs）或空格（spaces）对HTML标签做缩进，否则将影响格式。</p><p>在HTML块级标签内不能使用Markdown语法。例如<code>&lt;p&gt;italic and **bold**&lt;/p&gt;</code> 将不起作用。</p><h1 id="三扩展语法">三、扩展语法</h1><h2 id="markdown扩展语法入门">Markdown扩展语法入门</h2><p>JohnGruber的原始设计文档中概述的基本语法主要是为了应付大多数情况下的日常所需元素，但对于某些人来说还不够，这就是扩展语法的用武之地。</p><p>一些个人和组织开始通过添加其他元素（例如表，代码块，语法突出显示，URL自动链接和脚注）来扩展基本语法。可以通过使用基于基本Markdown语法的轻量级标记语言，或通过向兼容的Markdown处理器添加扩展来启用这些元素。## Markdown扩展语法可用性并非所有Markdown应用程序都支持扩展语法元素。您需要检查您的应用程序所使用的轻量级标记语言是否支持您要使用的扩展语法元素。如果没有，那么仍然有可能在Markdown处理器中启用扩展。### 轻量标记语言有几种轻量级标记语言是Markdown的超集（反过来说Markdown是它们的子集）。它们包含Gruber的基本语法，并通过添加其他元素（例如表，代码块，语法突出显示，URL自动链接和脚注）在此基础上构建。许多最受欢迎的Markdown应用程序使用以下轻量级标记语言之一：* <a href="https://commonmark.org/">CommonMark</a> * <a href="https://github.github.com/gfm/">GitHub Flavored Markdown (GFM)</a>* <a href="https://michelf.ca/projects/php-markdown/extra/">MarkdownExtra</a> * <a href="https://fletcherpenney.net/multimarkdown/">MultiMarkdown</a> * <a href="https://rmarkdown.rstudio.com/">R Markdown</a> ### Markdown 处理器有许多<a href="https://github.com/markdown/markdown.github.com/wiki/Implementations">Markdown处理器</a>可用。它们中的许多允许您添加启用扩展语法元素的扩展。查看您所使用处理器的文档以获取更多信息。## Markdown表格要添加表，请使用三个或多个连字符（<code>---</code>）创建每列的标题，并使用管道（<code>|</code>）分隔每列。您可以选择在表的任一端添加管道。<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> Syntax      </span>|<span class="hljs-string"> Description </span>|<br>|<span class="hljs-string"> ----------- </span>|<span class="hljs-string"> ----------- </span>|<br>|<span class="hljs-string"> Header      </span>|<span class="hljs-string"> Title       </span>|<br>|<span class="hljs-string"> Paragraph   </span>|<span class="hljs-string"> Text        </span>|<br></code></pre></td></tr></table></figure> 呈现出的输出如下所示： | Syntax | Description | |----------- | ----------- | | Header | Title | | Paragraph | Text |单元格的宽度可依变化，如下所示。呈现的输出将看起来相同。 <figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> Syntax </span>|<span class="hljs-string"> Description </span>|<br>|<span class="hljs-string"> --- </span>|<span class="hljs-string"> ----------- </span>|<br>|<span class="hljs-string"> Header </span>|<span class="hljs-string"> Title </span>|<br>|<span class="hljs-string"> Paragraph </span>|<span class="hljs-string"> Text </span>|<br></code></pre></td></tr></table></figure><strong>Tip:</strong>使用连字符和管道创建表可能很麻烦。为了加快该进程，请尝试使用<a href="https://www.tablesgenerator.com/markdown_tables">Markdown TablesGenerator</a>。使用图形界面构建表，然后将生成的Markdown格式的文本复制到文件中。### 对齐您可以通过在标题行中的连字符左侧，右侧或两侧添加冒号（<code>:</code>），将列中的文本对齐到左侧，右侧或中心。<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> Syntax      </span>|<span class="hljs-string"> Description </span>|<span class="hljs-string"> Test Text     </span>|<br>|<span class="hljs-string"> :---        </span>|<span class="hljs-string">    :----:   </span>|<span class="hljs-string">          ---: </span>|<br>|<span class="hljs-string"> Header      </span>|<span class="hljs-string"> Title       </span>|<span class="hljs-string"> Here&#x27;s this   </span>|<br>|<span class="hljs-string"> Paragraph   </span>|<span class="hljs-string"> Text        </span>|<span class="hljs-string"> And more      </span>|<br></code></pre></td></tr></table></figure> 呈现的输出如下所示： | Syntax | Description | Test Text || :--- | :----: | ---: | | Header | Title | Here's this | | Paragraph |Text | And more | ### 格式化表格中的文字您可以在表格中设置文本格式。例如，您可以添加链接，代码（仅反引号（<code>`</code>）中的单词或短语，而不是代码块）和强调。</p><p>您不能添加标题，块引用，列表，水平规则，图像或HTML标签。 ###在表中转义管道字符您可以使用表格的HTML字符代码（<code>&amp;#124;</code>）在表中显示竖线（<code>|</code>）字符。## Markdown围栏代码块Markdown基本语法允许您通过将行缩进四个空格或一个制表符来创建代码块。如果发现不方便，请尝试使用受保护的代码块。根据Markdown处理器或编辑器的不同，您将在代码块之前和之后的行上使用三个反引号（<code>```</code>）或三个波浪号（<code>~~~</code>）。<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">```<br>&#123;<br>  <span class="hljs-string">&quot;firstName&quot;</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-string">&quot;lastName&quot;</span>: <span class="hljs-string">&quot;Smith&quot;</span>,<br>  <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">25</span><br>&#125;<br>```<br></code></pre></td></tr></table></figure> 呈现的输出如下所示： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Smith&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">25</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure> <strong>Tip:</strong>要在代码块中显示反引号？使用<code>````</code>代替<code>```</code>括住代码区域即可。### 语法高亮许多Markdown处理器都支持受围栏代码块的语法突出显示。使用此功能，您可以为编写代码的任何语言加颜色突出显示。要添加语法突出显示，请在受防护的代码块之前的反引号旁指定一种语言。<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">```json<br>&#123;<br>  <span class="hljs-string">&quot;firstName&quot;</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-string">&quot;lastName&quot;</span>: <span class="hljs-string">&quot;Smith&quot;</span>,<br>  <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">25</span><br>&#125;<br>```<br></code></pre></td></tr></table></figure> 呈现的输出如下所示： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Smith&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">25</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure> ## Markdown脚注脚注使您可以添加注释和参考，而不会使文档正文混乱。当您创建脚注时，带有脚注的上标数字会出现在您添加脚注参考的位置。读者可以单击链接以跳转至页面底部的脚注内容。</p>要创建脚注参考，请在方括号（<code>&lt;sup id="fnref:1" class="footnote-ref"&gt;&lt;a href="#fn:1" rel="footnote"&gt;&lt;span class="hint--top hint--rounded" aria-label="My footnote.</code>）您不必在文档末尾添加脚注。您可以将它们放在除列表，块引号和表的其他元素之外的任何位置。<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre><pre><code class="hljs pgsql">Her<span class="hljs-string">e&#x27;s a simple footnote,[^1] and here&#x27;</span>s a longer one.[^bignote]<br><br>[^<span class="hljs-number">1</span>]: This <span class="hljs-keyword">is</span> the first footnote.<br><br>[^bignote]: Her<span class="hljs-string">e&#x27;s one with multiple paragraphs and code.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Indent paragraphs to include them in the footnote.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    `&#123; my code &#125;`</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Add as many paragraphs as you like.</span><br></code></pre><p>呈现的输出如下所示： Here's a simplefootnote,"&gt;[1]`）内添加插入符号和标识符。标识符可以是数字或单词，但不能包含空格或制表符。标识符仅将脚注参考与脚注本身相关联。在输出中，脚注按顺序编号。</p>在括号内使用另一个插入符号和数字添加脚注，并用冒号和文本（<code>&lt;sup id="fnref:1" class="footnote-ref"&gt;&lt;a href="#fn:1" rel="footnote"&gt;&lt;span class="hint--top hint--rounded" aria-label="My footnote.</code>）您不必在文档末尾添加脚注。您可以将它们放在除列表，块引号和表的其他元素之外的任何位置。<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre><pre><code class="hljs applescript">[^<span class="hljs-number">1</span>]: This <span class="hljs-keyword">is</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> footnote.<br><br>[^bignote]: Here&#x27;s one <span class="hljs-keyword">with</span> multiple <span class="hljs-built_in">paragraphs</span> <span class="hljs-keyword">and</span> code.<br><br>    Indent <span class="hljs-built_in">paragraphs</span> <span class="hljs-keyword">to</span> include them <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> footnote.（段落缩进以使它们包含在脚注中）<br><br>    `&#123; <span class="hljs-keyword">my</span> code &#125;`<br><br>    Add <span class="hljs-keyword">as</span> many <span class="hljs-built_in">paragraphs</span> <span class="hljs-keyword">as</span> you like.<br></code></pre><p>呈现的输出如下所示： Here's a simplefootnote,"&gt;[1] and here's a longer one.[^bignote]<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">### My Great Heading &#123;#custom-id&#125;<br></code></pre></td></tr></table></figure> ## Markdown标题编号 许多Markdown处理器支持标题的自定义ID——一些Markdown处理器会自动添加它们。添加自定义ID允许您直接连接到标题并使用CSS对其进行修改。要添加自定义标题ID，请在与标题相同的行上用大括号括起该自定义ID。<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;custom-id&quot;</span>&gt;</span>My Great Heading<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br></code></pre></td></tr></table></figure> HTML看起来像这样： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">First Term<br>: This is <span class="hljs-keyword">the</span> definition <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> term.<br><br>Second Term<br>: This is <span class="hljs-literal">one</span> definition <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">second</span> term.<br>: This is another definition <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">second</span> term.<br></code></pre></td></tr></table></figure> ###连接到标题ID（#headid）通过创建带有数字符号（<code>#</code>）和自定义标题ID的标准链接，可以链接到文件中具有自定义ID的标题。</p><table><thead><tr class="header"><th>Markdown</th><th>HTML</th><th>预览效果</th></tr></thead><tbody><tr class="odd"><td><code>[Heading IDs](#heading-ids)</code></td><td><code>&lt;a href="#heading-ids"&gt;Heading IDs&lt;/a&gt;</code></td><td><a href="#heading-ids">Heading IDs</a></td></tr></tbody></table><p>其他网站可以通过将自定义标题ID添加到网页的完整URL（例如<code>[Heading IDs](https://markdown.com.cn/extended-syntax/heading-ids.html#headid)</code>）来链接到标题。## Markdown定义列表一些Markdown处理器允许您创建术语及其对应定义的<em>定义列表</em>。要创建定义列表，请在第一行上键入术语。在下一行，键入一个冒号，后跟一个空格和定义。<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>First Term<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>This is the definition of the first term.<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Second Term<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>This is one definition of the second term. <span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>This is another definition of the second term.<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure> HTML看起来像这样： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml">~~世界是平坦的。~~ 我们现在知道世界是圆的。<br></code></pre></td></tr></table></figure> 呈现的输出如下所示：First Term : This is the definition of the first term. Second Term :This is one definition of the second term. : This is another definitionof the second term. ## Markdown删除线您可以通过在单词中心放置一条水平线来删除单词。结果看起来<del>像这样</del>。此功能使您可以指示某些单词是一个错误，要从文档中删除。若要删除单词，请在单词前后使用两个波浪号<code>~~</code>。<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>[x] Write the press release<br><span class="hljs-bullet">- </span>[ ] Update the website<br><span class="hljs-bullet">- </span>[ ] Contact the media<br></code></pre></td></tr></table></figure> 呈现的输出如下所示： <del>世界是平坦的。</del>我们现在知道世界是圆的。 ## Markdown任务列表语法任务列表使您可以创建带有复选框的项目列表。在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。要创建任务列表，请在任务列表之前添加破折号<code>-</code>和方括号<code>[]</code>，并在<code>[]</code>前面加上空格。要选择一个复选框，请在方括号<code>[x]</code>之间添加x。<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">去露营了！ <span class="hljs-symbol">:tent</span>: 很快回来。<br><br>真好笑！ <span class="hljs-symbol">:joy</span><span class="hljs-symbol">:</span><br></code></pre></td></tr></table></figure> 呈现的输出如下所示： - [x] Write the press release - [ ]Update the website - [ ] Contact the media ## Markdown使用Emoji表情有两种方法可以将表情符号添加到Markdown文件中：将表情符号复制并粘贴到Markdown格式的文本中，或者键入emojishortcodes。</p><h3 id="复制和粘贴表情符号">复制和粘贴表情符号</h3><p>在大多数情况下，您可以简单地从<a href="https://emojipedia.org/">Emojipedia</a>等来源复制表情符号并将其粘贴到文档中。许多Markdown应用程序会自动以Markdown格式的文本显示表情符号。从Markdown应用程序到处的HTML和PDF文件应显示表情符号。</p><p><strong>Tip:</strong>如果您使用的时静态网站生成器，请确保HTML页面编码为UTF-8。 ###使用表情符号简码一些Markdown应用程序允许您通过键入表情符号短代码来插入表情符号。这些以冒号开头和结尾，并包含表情符号的名称。<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>www.example.com<br></code></pre></td></tr></table></figure> 呈现的输出如下所示：</p><p>去露营了！ :tent: 很快回来。</p><p>真好笑！ :joy:</p><p><strong>Note:</strong>注意：您可以使用此表情符号简码列表，但请记住，表情符号简码因应用程序而异。有关更多信息，请参阅Markdown应用程序的文档。## 自动网址链接许多Markdown处理器会自动将URL转换为链接。这意味着如果您输入<code>http://www.example.com</code>，即使您未使用方括号，您的Markdown处理器也会自动将其转换为链接。<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">`http:<span class="hljs-regexp">//</span>www.example.com`<br></code></pre></td></tr></table></figure> 呈现的输出如下所示：</p><p>http://www.example.com</p><h3 id="禁用自动url链接">禁用自动URL链接</h3><p>如果您不希望自动URL链接，则可以通过将URL表示为带反引号的代码来删除该链接。<figure class="highlight awk"><table><tr><td class="gutter">undefined</td><td class="code">undefined</td></tr></table></figure> 呈现的输出如下所示：</p><code>http://www.example.com</code><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Myfootnote.`）您不必在文档末尾添加脚注。您可以将它们放在除列表，块引号和表的其他元素之外的任何位置。<figure class="highlight pgsql"><table><tr><td class="gutter">undefined</td><td class="code">undefined</td></tr></table></figure> 呈现的输出如下所示： Here's a simple footnote,<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows下部署Hexo博客过程</title>
    <link href="/2023/09/20/Windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/09/20/Windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>本过程完全按照CodeSheep的视频（https://www.bilibili.com/video/BV1Yb411a7ty）操作，区别是在Windows环境下而非MacOS下部署。在此描述出所有步骤，以及踩过的一些坑。</p><h1 id="一前置环境搭建">一、前置环境搭建</h1><h2 id="node.jsnpm安装">Node.JS、npm安装</h2><p>进入官网 https://nodejs.org 选择LTS(Long TermSupport)版本执行全默认安装即可。</p><p>使用PowerShell（管理员模式）输入命令：<br><code>node -v</code><br>验证安装是否成功</p><h2 id="cnpm安装">cnpm安装</h2><p><code>npm install -g cnpm --registry=http://registry.npm.taobao.org  #安装淘宝源的 cnpm 管理器</code></p><h2 id="两个坑">两个坑</h2><ul><li><p>安装cnpm提示"x packages are looking for funding."<br>可选择忽略或install或使用<br><code>npm install --no-fund  -g cnpm --registry=http://registry.npm.taobao.org</code><br>的方式跳过fund。<sup>[1]</sup></p></li><li><p>输入 cnpm -v 后提示"无法加载文件C:*****.ps1，因为在此系统上禁止运行脚本"<br>请使用命令<br><code>set-ExecutionPolicy RemoteSigned</code><br>允许在系统上运行脚本。<sup>[2]</sup></p></li></ul><hr><h1 id="二hexo框架安装与配置">二、Hexo框架安装与配置</h1><h2 id="hexo框架安装">Hexo框架安装</h2><p><code>cnpm install -g hexo-cli</code></p><h2 id="坑">坑</h2><ul><li><p>安装过程提示需要git<br>https://git-scm.com/download/win官方提供两种方式安装，这里使用PowerShell中的命令行安装，命令如下：<br><code>winget install --id Git.Git -e --source winget</code><br>重启PowerShell后即安装成功</p></li><li><p>Git报错： Failed to connect to github.com port 443 解决方案<br>由于我手里有魔法，故根据CSDN上的教程<sup>[3]</sup>修改sock5和http代理即可</p></li></ul><h2 id="hexo的配置">Hexo的配置</h2><ul><li><p>选择一个目标位置创建Blog文件夹（这里选择C:）<br><code>mkdir blog</code><br><code>cd blog</code></p></li><li><p>初始化<br><code>hexo init #win环境下无需sudo，管理员模式启动即可</code></p></li></ul><hr><h1 id="三常用命令">三、常用命令</h1><ul><li><p>本地预览<br><code>hexo server #或 hexo s 启动预览</code><br>进入 http://localhost:4000/ 本地访问地址</p></li><li><p><code>hexo new "我的第一篇文章" #或 hexo n 创建新的文章</code></p></li><li><p><code>hexo clean #或 hexo c 清理</code></p></li><li><p><code>hexo generate #或 hexo g 生成</code></p></li><li><p><code>hexo deploy #或 hexo d部署到远端</code></p></li></ul><hr><h1 id="四部署到远端以github为例">四、部署到远端（以Github为例）</h1><h2 id="登录github创建一个新的仓库">登录Github创建一个新的仓库</h2><p>坑：<br>· 必须以 用户名.github.io的形式命名仓库<br>· 必须是public库而非private库，否则可能会遇到404问题</p><h2 id="在blog目录下安装git部署插件">在Blog目录下安装git部署插件</h2><p><code>cnpm install --save hexo-deployer-git #注意必须是Blog目录下，否则请删除Blog重来</code>## 配置Blog目录下的 _config.yml 文件<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts">   \<span class="hljs-meta"># Deployment  </span><br>\<span class="hljs-meta">## Docs: https:<span class="hljs-comment">//hexo.io/docs/deployment.html  </span></span><br><span class="hljs-symbol">deploy:</span>  <br><span class="hljs-symbol"> type:</span> git  <br><span class="hljs-symbol">repo:</span> https:<span class="hljs-comment">//github.com/YourGithubName/YourGithubName.github.io.git  </span><br><span class="hljs-symbol"> branch:</span> master  <br></code></pre></td></tr></table></figure></p><h2 id="部署到远端">部署到远端</h2><p><code>hexo deploy #或hexo d</code> ## 访问博客<br>https://YourGithubName.github.io.git即你的博客地址</p><hr><h1 id="五更换博客皮肤非必须以yilia为例">五、更换博客皮肤（非必须，以Yilia为例）</h1><ul><li><code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia  #下载yilia主题到本地</code></li></ul><h2 id="修改_config.yml配置文件">修改_config.yml配置文件</h2><ul><li>theme: landscape 改为 theme: yilia</li></ul><h2 id="清理生成部署查看">清理、生成、部署、查看</h2><ul><li><code>hexo c #清理</code><br></li><li><code>hexo g #生成</code></li><li><code>hexo d #部署</code></li><li>访问 https://YourGithubName.github.io.git #查看</li></ul><hr><h1 id="tips">Tips</h1><ul><li>博文的具体内容在 /Blog/source/_posts/我的第一篇文章.md中修改</li><li>推荐使用开源软件 VSCode + 插件MarkDown All inOne查看修改.md文件</li></ul><hr><h1 id="参考资料">参考资料</h1><p>[1] https://www.likecs.com/ask-545634.html<br>[2] https://zhuanlan.zhihu.com/p/617284262<br>[3] https://blog.csdn.net/zpf1813763637/article/details/128340109</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
